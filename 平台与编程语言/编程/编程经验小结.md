| 序号 | 修改时间  | 修改内容                                           | 修改人 | 审稿人 |
| ---- | --------- | -------------------------------------------------- | ------ | ------ |
| 1    | 2016-3-26 | 将原《编程经验》和《高质量编程》文档汇总。         | Keefe |        |
| 2    | 2017-2-6  | 将搜索引擎编程经验章节合并到《搜索引擎的关键算法》 | 同上   |        |
| 3    | 2018-9-6  | 将安全编程章节迁移到《安全开发》                   | 同上   |        |
<br><br><br>

----

# 目录

[目录... 1](#_Toc524041092)

[1.   高质量编程... 2](#_Toc524041093)

[1.1        编码实践中的潜规则... 2](#_Toc524041094)

[1.1.1         谁在维护程序... 2](#_Toc524041095)

[1.1.2         编写无错代码... 2](#_Toc524041096)

[1.1.3         谁来测试代码... 2](#_Toc524041097)

[1.1.4         安全与效率的平衡... 2](#_Toc524041098)

[2       开发小技巧... 3](#_Toc524041099)

[2.1        空行 black line. 3](#_Toc524041100)

[3       调试经验... 3](#_Toc524041101)

[3.1        VC7.0常见调试问题... 3](#_Toc524041102)

[3.2        文件IO要注意的问题... 5](#_Toc524041103)

[参考资料... 6](#_Toc524041104)
<br><br><br>

---


# 1 高质量编程

## 1.1   编码实践中的潜规则

### 1.1.1   谁在维护程序

在Microsoft公司，每个程序员编写新代码的数量，与他对所从事研制的产品内部情况的熟悉程度成正比，对产品比较熟悉的程序员，编写新代码的是多一些，而较少进行维护性的程序设计。当然，如果对项目了解很少那么就要花大量时间来阅读别人写的代码、修改别人的错误、对于已有特征作少量的局部性的增补。直观地看，这种安排很有意义。如果你不知道系统是怎样写的，那你就不能给系统增加重要的功能。

一般来说，有经验的程序员编写出代码，新手维护代码。我并不是说不应该这样安排，这种安排是实用的而且就是这么作的。但是，只有在有经验的程序员认识到，他们有责任使得他们所编写的代码，能够被程序维护人员和程序设计新手维护，这时这种安排才能行得通。

因此，编写直观的代码才是真正的聪明人。

### 1.1.2   编写无错代码

错误消失了,这是什么原因? 错误既不会自己产生，也不会自己改正。如果你得到了一个错误报告，但这个错误不再出现了。不要假设测试员发生了幻觉，而要努力查找错误，甚至要恢复程序的老版本。错误消失有三个原因：一是错误报告不对；二是错误已被别的程序员改正了；三是这个错误依然存在但没有表现出来。也就是说，作为一个专业程序员，其职责之一就是要确定错误的消失究竟属于以上三种情况中的哪一种，从而采取相应的行动，但是决不能因为错误不出现就简单地忽略了它，就万事大吉了。

### 1.1.3   谁来测试代码

测试代码的责任不在测试员身上，而是程序员自己的责任. 程序员测试代码，是从里向外测试，而测试员则是从外向里测试。程序员首先要进行单元测试,测试成功后才能交付给测试员进行黑盒测试. 之所以这样，是因为程序员强调的是代码而测试员强调的是特征，两者从不同的方位考虑问题，这就增加了发现未知错误的机会。

### 1.1.4   安全与效率的平衡

​       程序中要做一些出错处理,增加一些异常处理的代码,如内存分配错误,如函数中返回值的判断,如其它可能的异常情况.总之,为了这许许多多的意外,就要增加额外的检测处理.有人使用了预编译宏来将整洁版本和臃肿版本隔开,也有人使用断言让代码看起来简洁.

​       怎么做到安全与效率的平衡,是程序员要掌握的平衡之道.如内部的测试程序,如果我们可以保证输入条件肯定是合法的,那就无需加入对输入条件的判断.

​       当然,这种平衡是很难把握的,更保险的方法是给每一个可能的出错都留有反悔的机会,这更安全些.在商业应用中,安全比效率重要多了.



<br>

# 2 开发小技巧

## 空行 black line

windows和linux的空行机制是不一样的.

windows系统下,纯文本中一个空行由一个回车符(carriage return,CR)和一个换行符组成,即C语言中的"\r\n";

linux系统下,一个空行仅由一个换行符组成,即C语言中的"\n"组成.

由此产生两种文件格式:unix/mac文件格式,dos文件格式.在跨平台进行操作文本文件时,要注意文件格式的转化.



因此得到下面两个使用经验:

1. **文件打开模式**

用标准IO库打开文件有两种模式:文本文件或二进制文件;

在linux下这两种模式没有区别,但在windows下,以文本模式打开,"\r\n"会被当成一个字符,即空行.因此,为了兼容,最好用二进制打开文件.

2. **FTP传输**

类似文件打开,FTP传输同样也有以上两种模块,因此为了兼容,最好用二进制格式进行传输.



##  效率评估

按照经验: 通常CPU使用率不应该超过50%,磁盘使用率不应该超过80%(包括内存使用+硬盘空间),否则机器会运行得很慢,影响程序的正常运行.



## 文件编码

现在文件编码通常有utf-8,gb2312....



<br>

# 3  调试经验

## 3.1   VC7.0常见调试问题

1. disable

```c
#pragma warning (disable: 4311 4312)        //指针类型强制转化,大小不完全匹配
warning C4311: 'type cast' : pointer truncation from 'TriNode *const ' to 'long'
warning C4312: 'type cast' : conversion from 'unsigned int' to 'SAC_Node_Add *' of greater size
// 注: 64位编程时,c4311的警告要处理,c412可以不处理.

#pragma warning (disable: 4244 4267)   //丢失数据,4244为已知类型,4267为64位类型转化
warning C4244: '=' : conversion from 'long' to 'char', possible loss of data
warning C4267: '=' : conversion from 'size_t' to 'long', possible loss of data

#pragma warning (disable: 4996)    //安全警告
warning C4996: 'fopen' was declared deprecated
```



2. MSVCR80D.dll

fat32的文件系统的时间戳有问题，ntfs分区下就没这个问题.

解决方案是：在编辑状态下，点项目菜单 -> property -> 配置属性 -> 清单工具，将右面的“使用FAT32解决办法”选为“是”即可。



3. 调试参数选项

a) 行号设置: Tools->Options->Text   Editor->C/C++,  display: line numbers勾选上

b) 调试变量中使用10进制数字: 在调试器窗口中右击,16进制显示勾去掉.

c) 工作路径: 右击工程属性页property page,General-->output directory;

d) 可执行程序: 右击工程属性页property page, debugging-->command;

e) 设置预编译头文件: 现象:fatal error C1010: unexpected end of file while looking for precompiled header directive,

解决方法: 右击项目工程中的该cpp文件，property page, c/c++-->precompiled headers,选择第一项,不使用预编译头文件;

4. 调试DLL

不能进入到DLL的source code中,解决方法如下:

一是clean-->rebuild;

二是设置项目依赖关系; 如果不行的话,就有可能是某个文件的注释或者其它莫名其妙的原因导致出错,就对要进入的那个文件重新分析,最好恢复到上次能进入的页面看是什么导致出错.



5. 64位数输出

```c
_int64 num1;
printf("%I64d", num1);
```

在gcc可用%ll直接得到64位输出. typedef long long _int64;

NOTE:VC下不支持long long数据类型,只能使用MS的_int64,下面分别是vc下64的无符号,有符号,16进制输出格式

```c
#define HOST_WIDEST_INT_PRINT_DEC       "%I64d"
#define HOST_WIDEST_INT_PRINT_UNSIGNED  "%I64u"
#define HOST_WIDEST_INT_PRINT_HEX       "0x%I64x"
```

6. winsock2.h与windows.h重定义的问题

方案1: 在windows.h前加 宏定义WIN32_LEAN_AND_MEAN

```c
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
```

方案2: 在 windows.h 前先 导入winsock2.h

7. error

要注意变量的生存周期,在for,while语句里的变量如果下面还要使用,那么此变量要提前到语句之前申明;



## 3.2 文件IO要注意的问题

a).文件句柄: 数字的文件描述符,一个进程能打开的所有文件句柄总数是有限制的,经测试<1024(系统限制数),此外,进程关闭,所有此进程打开的文件句柄自动关闭;文件句柄是可重用的,每次得到的文件句柄一定是最小的未用的;所以同一线程不断打开关闭,可能获得句柄指针是一样的,而且线程ID也可能一样;

b).IO的效率: 最好BUFFSIZE的大小与文件块长相同,如常见的8k一块的文件系统,效率最高;

c).文件共享:内核维护三种数据结构:进程表项,文件表项,文件节点结构;此三张表构成了文件与进程之间的关系.也是理解文件读写加锁的关键; 注意每个进程都在进程表项中占有一个位置,每个进程都指向一个进程相关的打开文件表项,而每个文件维护一个文件节点结构.所以,各进程独享的变量是文件描述符,打开文件的文件状态标志,当前文件偏移位置;而每个文件的文件长度,所有者,设备,磁盘中的位置指针等是各进程共享变量.

d).文件路径:用./来表示下层目录,也可用.\\来表示,\是转义符,表示'\'要用'\\'.

e).锁的技巧:文件级,字节级;

f). 函数的使用技巧:

  不带缓存的IO是指系统调用函数:read,write,lseek,open,close...

  lseek.fseek仅将当前文件位移量记录在内核,允许文件位移量大于文件大小,不引起IO操作,因此本函数通常不会出错,lseek是为下一步读写函数服务的.要对文件读写函数进行判断,fread,fwrite,若出错,就要关闭文件指针.每次读写操作后,位移量要进行变动,才能进行下一步操作,否则操作的是一次同一个位置,除非打开文件使用append方式.(换句言,每次读定操作写,先要定位偏移量).

  多进程读同一个文件能正常工作,因为每个进程各有自己的文件表项,当中有自己的文件位移量;但多进程同写一个文件则可能会出错,因此要把lseek,write作为一个原子操作.在windows平台,线程与进程在内核是等同的(?),所以多进程操作类似多线程.



# FAQ

**FAQ1: 多级指针初始化**

a)  long* m_ltest1= new long;

b)  long** m_cppValue1;

```c
   m_cppValue1 = new long* [3];
   for(i = 0; i < 3; i++){ m_cppValue1[i] = new long [m_lMaxDocId]; }
```



c)  long*** m_cppValue;

```c++
m_cppValue = new long**[M];
for(i = 0; i < M; i++){
	m_cppValue[i] = new long*[N];
	for(j = 0; j < N; j++){
	m_cppValue[i][j] = new long;
	}
}

//释放内存时的顺序刚好相反,先删除最低层元素空间.
for(i = 0; i < M; i++){
	for(j = 0; j < N; j++){
	if(m_cppValue[i][j]) delete m_cppValue[i][j];
	}
	if(m_cppValue[i]) delete m_cppValue[i];
}
if(m_cppValue)	delete m_cppValue;
```



<br>

# 参考资料

* 《高质量编程》
