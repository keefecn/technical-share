| 序号 | 修改时间   | 修改内容                                         | 修改人 | 审稿人 |
| ---- | ---------- | ------------------------------------------------ | ------ | ------ |
| 1    | 2014-10-23 | 创建：把历年的安全相关文章组合在一起。           | Keefe |        |
| 2    | 2016-4-10  | 增加新章节：黑客技术                             | 同上   |        |
| 3    | 2016-7-19  | 增加网站攻击章节                                 | 同上   |        |
| 4    | 2016-10-19 | 增加互联网安全大事记                             | 同上   |        |
| 5    | 2017-11-25 | 更新安全知识域、安全架构、安全编程章节           | 同上   |        |
| 6    | 2018-5-1   | 将《进程间通信》整体迁移到这。                   | 同上   |        |
| 7    | 2018-9-3   | 更新安全算法章节，将并发章节迁移到《性能优化》。 | 同上   |        |
|      |            |                                                  |        |        |





---


# 目录

[目录... 1](#_Toc524041370)

[1    安全知识域... 4](#_Toc524041371)

[1.1       概述... 4](#_Toc524041372)

[2    安全OS. 4](#_Toc524041373)

[2.1       UNIX系统安全... 4](#_Toc524041374)

[2.1.1     设置健壮的密码... 4](#_Toc524041375)

[2.1.2     删除所有的特殊账户... 5](#_Toc524041376)

[2.1.3     关闭不需要的服务... 5](#_Toc524041377)

[2.1.4     远程登陆管理... 6](#_Toc524041378)

[2.1.5     日志监控... 7](#_Toc524041379)

[2.2       Linux系统安全... 8](#_Toc524041380)

[2.2.1     LINUX安全设置手册... 8](#_Toc524041381)

[2.2.2     Linux服务器安全加固... 10](#_Toc524041382)

[2.2.3     SELinux中的Apache和MySQL设定... 11](#_Toc524041383)

[2.3       WINDOWS系统安全... 13](#_Toc524041384)

[2.4       本章参考... 13](#_Toc524041385)

[3    安全认证和授权... 13](#_Toc524041386)

[3.1       权限管理模型... 13](#_Toc524041387)

[3.2       认证... 14](#_Toc524041388)

[3.2.1     认证机制... 14](#_Toc524041389)

[3.2.2     OpenID.. 16](#_Toc524041390)

[3.2.3     LDAP. 17](#_Toc524041391)

[3.2.4     Kerberos. 20](#_Toc524041392)

[3.2.5   JWT - JSON Web Token.. 21](#_Toc524041393)

[3.2.6     数字签名... 21](#_Toc524041394)

[3.2.7   基于证书的认证... 22](#_Toc524041395)

[3.3       授权... 23](#_Toc524041396)

[3.3.1     OAuth. 23](#_Toc524041397)

[3.4       HTTPS. 25](#_Toc524041398)

[3.4.1     HTTPS原理... 25](#_Toc524041399)

[3.4.2     证书... 26](#_Toc524041400)

[3.4.3     自签名证书... 27](#_Toc524041401)

[3.4.4     本节参考... 29](#_Toc524041402)

[3.5       相关技术... 29](#_Toc524041403)

[3.5.1     随机数、序列号和时间戳... 29](#_Toc524041404)

[3.5.2     加密解密... 30](#_Toc524041405)

[3.6       案例... 30](#_Toc524041406)

[3.6.1     MAZE的信用卡机制... 30](#_Toc524041407)

[3.7       本章参考... 32](#_Toc524041408)

[4    安全编程... 32](#_Toc524041409)

[4.1       内存管理... 32](#_Toc524041410)

[4.2       安全编程实践... 34](#_Toc524041411)

[4.2.1     使用断言进行防止错误... 34](#_Toc524041412)

[4.3       语言相关的安全编码... 34](#_Toc524041413)

[4.3.1     net中使用安全函数... 34](#_Toc524041414)

[4.3.2     PHP代码执行漏洞... 34](#_Toc524041415)

[5    安全算法... 35](#_Toc524041416)

[6    安全架构... 44](#_Toc524041422)

[7    业界范例... 45](#_Toc524041423)

[7.1       华为的安全白皮书... 45](#_Toc524041424)

[7.1.1     概述... 45](#_Toc524041425)

[7.1.2     IPD流程... 46](#_Toc524041426)

[7.1.3     信息安全... 47](#_Toc524041427)

[8    黑客技术... 48](#_Toc524041428)

[8.1       黑客的攻击思路... 48](#_Toc524041429)

[8.1.1     黑客常用工具... 48](#_Toc524041430)

[8.1.2     常见安全隐患... 50](#_Toc524041431)

[8.2       SQL注入... 50](#_Toc524041432)

[8.2.1     sql注入安全问题... 51](#_Toc524041433)

[8.3       浏览器安全和隐私... 52](#_Toc524041434)

[8.3.1     Cookie和session机制... 52](#_Toc524041435)

[8.3.2     浏览器模拟登陆... 55](#_Toc524041436)

[8.4       网站攻击... 55](#_Toc524041437)

[8.4.1     XSS跨站脚本... 55](#_Toc524041438)

[8.4.2     CSRF跨站攻击... 56](#_Toc524041439)

[8.4.3     flash安全问题... 57](#_Toc524041440)

[8.4.4     XML注入安全问题... 57](#_Toc524041441)

[8.4.5     其它漏洞... 58](#_Toc524041442)

[8.5       本章参考... 59](#_Toc524041444)

[9    安全大事记... 60](#_Toc524041445)

[9.1       互联网安全大事记... 60](#_Toc524041446)

[9.2       黑客史... 61](#_Toc524041447)

[9.3       信息安全发展史... 62](#_Toc524041448)

[9.4       参考资料... 62](#_Toc524041449)

[附录... 62](#_Toc524041450)

[信息网络安全资源... 62](#_Toc524041451)

[网络安全工具... 63](#_Toc524041452)

 

 

**表目录**

[表格 1 LINUX安全设置项列表__ 8](#_Toc524041453)

[表格 2 目录服务软件比较__ 17](#_Toc524041454)

[表格 3 LDAP协议的版本__ 17](#_Toc524041455)

[表格 4 LDAP基本术语__ 19](#_Toc524041456)

[表格 5 oAuth版本史__ 23](#_Toc524041457)

[表格 6 加密算法分类__ 35](#_Toc524041458)

[表格 7 对称与非对称算法比较__ 35](#_Toc524041459)

[表格 8 称加密算法(加解密密钥相同) 36](#_Toc524041460)

[表格 9 非对称算法(加密密钥和解密密钥不同) 36](#_Toc524041461)

[表格 10 散列算法比较__ 36](#_Toc524041462)

[表格 11加密算法的安全级别(Security Level of Cryptographic Algorithms) 36](#_Toc524041463)

[表格 12 非对称密钥加密算法安全性对比__ 37](#_Toc524041464)

[表格 13 AES与3DES的比较__ 37](#_Toc524041465)

[表格 14 简单的加密设计__ 37](#_Toc524041466)

[表格 15 单钥密码算法性能比较表__ 38](#_Toc524041467)

[表格 16 java加密算法列表__ 38](#_Toc524041468)

[表格 17 Cipher Algorithm Names 40](#_Toc524041469)

[表格 18 Cipher Algorithm Modes 42](#_Toc524041470)

[表格 19 Cipher Algorithm Padding_ 43](#_Toc524041471)

[表格 20 8.1互联网安全大事记列表__ 60](#_Toc524041472)

[表格 21 著名黑客列表__ 61](#_Toc524041473)

 

 



---

# 1  安全知识域

## 1.1  概述

​            ![image-20200108002744622](../media/domain/\security_001.png)                   

图 1 华为的企业网全网信息安全层次架构

 

# 2  安全OS

## 2.1  UNIX系统安全

### 2.1.1  设置健壮的密码

要求包含大小写字母，数字，特殊字符，长度要求8位以上。

root用户可以使用下面的命令和参数来增强对用户密码的管理：

`$passwd Cn 30 帐号名`   #强迫用户每30天修改一次密码

 

### 2.1.2  删除所有的特殊账户

你应该删除所有不用的缺省用户和组账户（比如lp,　sync,　shutdown,　halt,　news,　
 uucp,　operator,　games,　gopher等）。 

```shell
 #删除用户： 
 [root@kapil　/]# userdel LP　 
 #删除组： 
 [root@kapil　/]# groupdel LP　
```



在终端上打入下面的命令删掉下面的特权用账号： 
```sh
# 删除特权账号
userdel adm
userdel lp
userdel sync
userdel shutdown
userdel halt
userdel mail 

# 如果你不用sendmail服务器，就删除这几个帐号：
userdel news
userdel uucp
userdel operator
userdel games 

# 如果你不用X windows 服务器，就删掉这个帐号。
userdel gopher 

# 如果你不允许匿名FTP，就删掉这个用户帐号：
userdel ftp 
```



### 2.1.3  关闭不需要的服务

Unix系统中有许多用不着的服务自动处于激活状态，它们中可能存在的安全漏洞使攻击者甚至不需要账户就能控制机器。为了系统的安全，应把该关的功能关闭，该限制的文件限制访问权限。可以用如下方法来关闭：

- 编辑 /etc/service文件（参考/etc/xinted.d/中文件）,  Centos在 /lib/systemd/system/目录。

- 用”#”符号注释掉不需要的服务，使其处于不激活的状态；

- 另外可使用chkconfig –del 服务名 来删除不必要的服务。



[此条使用了新的xinetd, /etc/service, /etc/xinetd.d/*]
 取消并反安装所有不用的服务，这样你的担心就会少很多。察看"/etc/inetd.conf"文件，通过注释取
 消所有你不需要的服务（在该服务项目之前加一个"#"）。然后用"sighup"命令升级"inetd.conf"文件。 
 第一步：更改"/etc/inetd.conf"权限为600，只允许root来读写该文件。 
` [Root@kapil　/]#　chmod 600 /etc/inetd.conf `

 第二步：确定"/etc/inetd.conf"文件所有者为root。

 第三步：编辑　/etc/inetd.conf文件（vi　/etc/inetd.conf），取消下列服务（你不需要的）：ftp,　telnet,　shell,　login,　exec,　talk,　ntalk,　imap,　pop-2,　pop-3,　finger,　auth等等。把不需要的服务关闭可以使系统的危险性降低很多。 

 第四步：给inetd进程发送一个HUP信号： 
` [root@kapil　/]# killall　-HUP inetd `

 第五步：用chattr命令把/ec/inetd.conf文件设为不可修改，这样就没人可以修改它： 
` [root@kapil　/]# chattr　+i　/etc/inetd.conf`
 这样可以防止对inetd.conf的任何修改（以外或其他原因）。唯一可以取消这个属性的人只有root。如果要修改inetd.conf文件，首先要是取消不可修改性质： 
`[root@kapil　/]# chattr -i /etc/inetd.conf `

 

### 2.1.4  远程登陆管理

禁止不安全的rlogin. telnet，使用密钥管理的ssh，使用scp进行加密传输。

登陆日志可查看 /var/log/secure  

**1). UNIX下系统用户登陆的安全审计工具主要有lastlog和WTMP。**

安全日志文件一般在/var/log目录下，各种UNIX系统可能不同。

* lastlog文件 记录每个用户的最近一次登陆时间和每个用户的最初目的地。

* wtmp文件 记录用户登陆和退出时间。

 

**2). SSH服务**

修改ssh服务的默认端口，改完重启sshd激活修改项

```shell
vi /etc/ssh/sshd_config
PORT 22

# 改完重启sshd
sudo /etc/init.d/ssh restart
```



**3). FTP服务**

使用iptable来管理登陆的ip及用户。

/etc/service
```ini
ftp-data    20/tcp
ftp-data    20/udp
# 21 is registered to ftp, but also used by fsp
ftp       21/tcp
ftp       21/udp     fsp fspd
ssh       22/tcp             # SSH Remote Login Protocol
ssh       22/udp             # SSH Remote Login Protocol
telnet     23/tcp
telnet     23/udp
rtelnet     107/tcp             # Remote Telnet
rtelnet 	107/udp
```



### 2.1.5 **限制 IP访问**

首先修改 /etc/hosts.allow文件，将可访问服务器ssh服务的客户IP加入其中，格式如下

```ini
sshd:192.168.1.0/255.255.255.0
sshd: 202.114.23.45
sshd: 211.67.67.89
```

然后修改 /etc/hosts.deny文件，加入禁用其它客户连接ssh服务
`sshd: ALL`

### 2.1.6  日志监控

 系统管理员主要依靠系统的LOG，即我们时常所说的日志文件来获得[入侵](http://www.05112.org/)的痕迹及[入侵](http://www.05112.org/)者进来的IP和其他信息。当然也有些管理员使用第三方工具来记录侵入电脑的信息，这里主要讲的是一般U NIX系统里记录[入侵](http://www.05112.org/)踪迹的文件。  

 /var/log，一些版本的Solaris，Linux BSD，Free BSD使用这个位置；  
 /etc，大多数UNIX版本把utmp放在此处，一些也把wtmp放在这里，这也是 syslog.conf 的位置。  



下面列举一些文件的功能，当然他们也根据入侵的系统不同而不同。  

```shell
 acct 或 pacct，记录每个用户使用的命令记录；  
 access_log，主要使用来服务器运行了NCSA HTTPD，这个记录文件会有什么站点连接过你的服务器；  
 aculog，保存着你拨出去的MODEMS记录；  
 lastlog，记录了用户最近的登陆记录和每个用户的最初目的地，有时是最后不成功登陆的记录；  
 loginlog，记录一些不正常的登陆记录；  
 messages，记录输出到系统控制台的记录，另外的信息由syslog来生成；  
 security，记录一些使用UUCP系统企图进入限制范围的事例；  
 secure   远程登陆相关的日志
 sulog，记录使用su命令的记录；  
 utmp，记录当前登录到系统中的所有用户，这个文件伴随着用户进入和离开系统而不断变化；  
 utmpx，UTMP的扩展；  
 wtmp，记录用户登录和退出事件；  
 syslog，最重要的日志文件，使用syslogd守护程序来获得。  
```



 **日志信息：  ** 

```shell
/dev/log，一个UNIX域套接字，接受在本地机器上运行的进程所产生的消息；  
/dev/klog，一个从UNIX内核接受消息的设备；  
514端口，一个INTERNET套接字，接受其他机器通过UDP产生的syslog消息；  
Uucp，记录的UUCP的信息，可以被本地UUCP活动更新，也可有远程站点发起的动作修改，信息包括发出和接受的呼叫，发出的请求，发送者，发送时间和发送主机；  
lpd-errs，处理打印机故障信息的日志；  
ftp日志，执行带-l选项的ftpd能够获得记录功能；  
httpd日志，HTTPD服务器在日志中记录每一个WEB访问记录；  
history日志，这个文件保存了用户最近输入命令的记录；  
vold.log，记录使用外接媒介时遇到的错误记录。
```



在Linux系统中，有三个主要的日志子系统：
* 连接时间日志--由多个程序执行，把纪录写入到/var/log/wtmp 和 /var/run/utmp，login等程序更新wtmp和utmp文件，使系统管理员能够跟踪谁在何时登录到系统。
* 进程统计--由系统内核执行。当一个进程终止时，为每个进程往进程统计文件（pacct或acct）中写一个纪录。进程统计的目的是为系统中的基本服务提供命令使用统计。
* 错误日志--由syslogd（8）执行。各种系统守护进程、用户程序和内核通过syslog（3）向文件/var/log/messages 报告值得注意的事件。另外有许多UNIX程序创建日志。像HTTP和FTP这样提供网络服务的服务器也保持详细的日志。

 

## 2.2  Linux系统安全

备注: unix系统安全的注意事项一般也能用到Linux系统.

### 2.2.1 Linux安全设置手册

表格  Linux安全设置项列表

| 设置项                                      | 设置原因                                                     | 设置内容                                                     |
| ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Bios Security  [可选]                       | 一定要给Bios设置密码，以防通过在Bios中改变启动顺序，而可以从软盘启动。这样可以阻止别人试图用特殊的启动盘启动你的系统，还可以阻止别人进入Bios改动其中的设置（比如允许通过软盘启动等）。 |                                                              |
| grub Security [可选]                        | 这三个参数可以使你的系统在启动grub时就要求密码验证。         | $ vi /etc/ grub.conf  time-out,restricted,password           |
| 选择正确的密码 [必选]                       | 修改密码长度：在你安装linux时默认的密码长度是5个字节。但这并不够，要把它设为8。 | $ vi /etc/login.defs  <br>PASS_MIN_LEN　8                    |
| 打开密码的shadow支持功能 [必选]             | 打开密码的shadow功能，来对password加密。                     | 工具：/usr/sbin/authconfig  转化shadow格式：  $ pwcov, grpconv |
| root账户 [必选]                             | 系统管理员在离开系统之前忘记注销root账户，系统会自动注销。   | `$ vi /etc/profile`  <br>TMOUT=3600 # 单位为秒               |
| 取消普通用户的控制台访问权限  [必选]        | 应该取消普通用户的控制台访问权限，比如shutdown、reboot、halt等命令。 | `$ rm -f  /etc/security/console.apps/`                       |
| TCP_WRAPPERS [必选]                         | 使用TCP_WRAPPERS可以使你的系统安全面对外部入侵。             |                                                              |
| 禁止系统信息暴露  [红帽默认]                | 当有人远程登陆时，禁止显示系统欢迎信息。  在最后加"-h"可以使当有人登陆时只显示一个login:提示，而不显示系统欢迎信息。 | `$ vi /etc/inetd.conf`  telnet　　stream　　tcp　　　　　nowait　　root　　　　/usr/sbin/tcpd　　in.telnetd　-h |
|                                             | 在缺省情况下，当你登陆到linux系统，它会告诉你该linux发行版的名称、版本、内核版本、服务器的名称。 | # 注释输出到 issue项  `$ vi /etc/rc.d/rc.local    $ rm -f  /etc/issue　    $rm -f /etc/issue.net` |
| /etc/services文件免疫 [可选]                | 防止未经许可的删除或添加服务                                 | `$ chattr +i /etc/services`                                  |
| 不允许从不同的控制台进行root登陆 [可选]     | 在不需要登陆的TTY设备前添加"#"标志，来禁止从该TTY设备进行root登陆。 | `$ vi /etc/securetty`                                        |
| 禁止任何人通过su命令改变为root用户 [可选]   | 编辑su配置文件。  #这表明只有"wheel"组的成员可以使用su命令成为root用户。你可以把用户添加到"wheel"组，以使它可以使用su命令成为root用户。 | `$ vi /etc/pam.d/su`  auth　sufficient　/lib/security/pam_rootok.so　debug　    auth　required　/lib/security/Pam_wheel.so　group=wheel |
| 禁止Control-Alt-Delete　键盘关闭命令 [可选] | 注释命令。  # 激活修改    $ /sbin/init q                     | `$ vi /etc/inittab`  #ca::ctrlaltdel:/sbin/shutdown　-t3　-r　now |
| 设置脚本权限                                | 给执行或关闭启动时执行的程序的script文件设置权限。           | `$ chmod -R 700 /etc/rc.d/init.d/*`                          |
| 禁止不使用的SUID/SGID程序                   | 如果一个程序被设置成了SUID root，那么普通用户就可以以root身份来运行这个程序。网管应尽可能的少使用SUID/SGID　程序，禁止所有不必要的SUID/SGID程序。   $ find / -type f \( -perm -04000 -o -perm -02000 \) \-exec ls -lg {} \; | 查找使用's'位的程序  `$ find  / -perm -4000 -print`  <br>禁止选中的带有's'位的程序   `$ chmod a-s [program]` |
| 修改host.conf                               | 第一项设置首先通过DNS解析IP地址，然后通过hosts文件解析。  第二项设置检测是否"/etc/hosts"文件中的主机是否拥有多个IP地址（比如有多个以太口网卡）。  第三项设置说明要注意对本机未经许可的电子欺骗。 | `$ vi /etc/host.conf`   order bind,hosts   multi on   nospoof on |
| TCP_WRAPPERS设置                            | 详见 备注1                                                   |                                                              |
| Shell  logging [可选]                       | 详见 备注2                                                   |                                                              |

**备注**：

1. TCP_WRAPPERS设置:  使用TCP_WRAPPERS可以使你的系统安全面对外部入侵。

最好的策略就是阻止所有的主机（在"/etc/hosts.deny"　文件中加入"ALL:　ALL@ALL,　PARANOID"　），然后再在"/etc/hosts.allow"　文件中加入所有允许访问的主机列表。 
第一步：编辑 hosts.deny文件（vi　/etc/hosts.deny），加入下面这行 

```ini
# 这表明除非该地址包好在允许访问的主机列表中，否则阻塞所有的服务和地址。 
#　Deny　access　to　everyone.　 
ALL:　ALL@ALL,　PARANOID 
```

第二步：编辑 hosts.allow文件（vi　/etc/hosts.allow），加入允许访问的主机列表，比如： 

 ```ini
# 202.54.15.99和　foo.com是允许访问ftp服务的ip地址和主机名称。 
ftp:　202.54.15.99　foo.com 
 ```

第三步：tcpdchk程序是tepd wrapper设置检查程序。它用来检查你的tcp wrapper设置，并报告发现的潜在的和真实的问题。设置完后，运行下面这个命令： 
` [Root@kapil　/]#　tcpdchk`

 2. **Shell logging [可选]**
Bash shell在 `~/.bash_history`（"~/"表示用户目录）文件中保存了500条使用过的命令，这样可以使你输入使用过的长命令变得容易。每个在系统中拥有账号的用户在他的目录下都有一个".bash_history"文件。bash shell应该保存少量的命令，并且在每次用户注销时都把这些历史命令删除。

第一步： "/etc/profile"文件中的"HISTFILESIZE"和"HISTSIZE"行确定所有用户的".bash_history"文件中可以保存的旧命令条数。强烈建议把把"/etc/profile"文件中的"HISTFILESIZE"和"HISTSIZE"行的值设为一个较小的数，比如30。编辑profile文件（vi /etc/profile），把下面这行改为：
```ini
# 这表示每个用户的".bash_history"文件只可以保存30条旧命令。
HISTFILESIZE=30　 
HISTSIZE=30　
```

第二步：当用户每次注销时，删除".bash_history"文件。 
编辑.bash_logout文件(vi /etc/skel/.bash_logout)，添加下面这行： 

 ```ini
rm　-f　$HOME/.bash_history 
 ```



### 2.2.2 Linux服务器安全加固

**关于分区**

一个潜在的黑客如果要攻击你的Linux服务器，他首先就会尝试缓冲区溢出。在过去的几年中，以缓冲区溢出为类型的安全漏洞是最为常见的一种形式了。更为严重的是，缓冲区溢出漏洞占了远程网络攻击的绝大多数，这种攻击可以轻易使得一个匿名的Internet用户有机会获得一台主机的部分或全部的控制权！ 

为了防止此类攻击，我们从安装系统时就应该注意。如果用root分区纪录数据，如log文件和email，就可能因为拒绝服务产生大量日志或垃圾邮件，从而导致系统崩溃。所以建议为/var开辟单独的分区，用来存放日志和邮件，以避免root分区被溢出。最好为特殊的应用程序单独开一个分区，特别是可以产生大量日志的程序，还有建议为/home单独分一个区，这样他们就不能填满/分区了，从而就避免了部分针对Linux分区溢出的恶意攻击。 

 

**关于Ping** 

既然没有人能ping通你的机器并收到响应，你可以大大增强你的站点的安全性。你可以加下面的一行命令到/etc/rc.d/rc.local，以使每次启动后自动运行，这样就可以阻止你的系统响应任何从外部/内部来的ping请求。

echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all 

 

**关于用户资源**

对你的系统上所有的用户设置资源限制可以防止DoS类型攻击，如最大进程数，内存数量等。例如，对所有用户的限制， 编辑/etc/security/limits.con加入以下几行：

```ini
* hard core 0
* hard rss 5000
* hard nproc 20
```

你也必须编辑/etc/pam.d/login文件，检查这一行的存在：

session required /lib/security/pam_limits.so 

上面的命令禁止core files“core 0”，限制进程数为“nproc 50“，且限制内存使用为5M“rss 5000”。 

 

### 2.2.3 Linux防火墙

**备注： centos7版本对防火墙进行加强,不再使用原来的iptables, 启用firewalld。**

centos使用 systemctl 命令来管理后台服务service.  

常用命令:  `systemctl status|start|stop|disable|enable|is-enabled| [service]`

1. 防火墙  firewalld / iptables

   如果服务端口正常，但外界不可访问，可检测是否开启了防火墙

```shell
# 1.firewalld的基本使用
启动：  systemctl start firewalld
查状态：systemctl status firewalld 
停止：  systemctl disable firewalld
禁用：  systemctl stop firewalld
在开机时启用一个服务：systemctl enable firewalld.service
在开机时禁用一个服务：systemctl disable firewalld.service
查看服务是否开机启动：systemctl is-enabled firewalld.service
查看已启动的服务列表：systemctl list-unit-files|grep enabled
查看启动失败的服务列表：systemctl --failed

# 2.配置firewalld-cmd
查看版本： firewall-cmd --version
查看帮助： firewall-cmd --help
显示状态： firewall-cmd --state
查看所有打开的端口： firewall-cmd --zone=public --list-ports
更新防火墙规则： firewall-cmd --reload
查看区域信息:  firewall-cmd --get-active-zones
查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0
拒绝所有包：firewall-cmd --panic-on
取消拒绝状态： firewall-cmd --panic-off
查看是否拒绝： firewall-cmd --query-panic

# 3.配置规则
参数说明:
–add-service #添加的服务
–zone #作用域
–add-port=80/tcp #添加端口，格式为：端口/通讯协议
–permanent #永久生效，没有此参数重启后失效

# 示例:
firewall-cmd --zone=public --query-port=80/tcp
firewall-cmd --zone=public --query-port=8080/tcp
firewall-cmd --zone=public --query-port=3306/tcp
firewall-cmd --zone=public --add-port=8080/tcp --permanent
firewall-cmd --zone=public --add-port=3306/tcp --permanent
firewall-cmd --zone=public --query-port=3306/tcp
firewall-cmd --zone=public --query-port=8080/tcp
firewall-cmd --reload  # 重新加载后才能生效
```



**iptables (centos7之前)**

```sh
# 1.开放80，22，8080 端口
/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT
/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT
/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT

# 2.保存
/etc/rc.d/init.d/iptables save

# 3.查看打开的端口
/etc/init.d/iptables status

# 4.关闭防火墙 
# 1） 永久性生效，重启后不会复原 off/on
$ chkconfig iptables off

# 2） 即时生效，重启后复原 start/stop
$ service iptables stop
```



### SELinux

Fedora Core 3 在安装时默认激活SELinux。SELinux比普通的Linux内核提供了更高的安全性，理论上说，在系统因为未知漏洞溢出的时候，普通用户是不可能得到超级用户的权限了。

```shell
# 获取selinux状态： enable/Enforcing为开启，disable/Permissive为关闭
$ getenforce
Disabled

# 临时开启,关闭: 0时关闭，不带参数为开启
$ setenforce 0

# 永久关闭
$ vim /etc/sysconfig/selinux
SELINUX=enforcing #替换为SELINUX=disabled
```



#### SELinux中的Apache和MySQL设定

因为SELinux安全性的提高，导致我们在使用时，会发生一些我们以前从没遇到的问题。
 前两天我在使用Fedora Core 3搭建PHP+MySQL的WebServer时就遇到了一些问题。现在整理一下，如果您也遇到同样的问题，那么，看过这篇文章，就应该可以轻而易举的解决了。

 1.　Apache - Document root must be a directory 问题。
 有可能和这个问题并发的问题还有 403 Forbidden　禁止访问的问题。
    现象描述：
    不使用系统默认的 /var/www/html作为系统的Document Root，自己新建一个目录后修改 /etc/httpd/conf/httpd.conf 中的配置，然后重起Apache的Daemon，发现Apache无法起动，系统报错：
    　Document root must be a directory
    但是，我们设置的DocumentRoot 的确是一个目录，而且apache用户具有可读权限。
    另一种情况：新建一个虚拟目录或文件后，无法访问，显示 Forbidden, 403 Error，但文件或目录有可读权限。
    问题产生的原因：
    一开始我想来想去想不出为什么，但是给我感觉是权限的问题，用传统的Linux的思维方式来看，权限绝对没有问题。但是仔细一想，SELinux是不是会有其他安全的设定？
    检查 avc　message，查看 /var/log/messages文件，发现有类似以下内容的这样一段：
    Dec 24 17:54:59 hostname kernel: audit(1098222899.827:0): avc:　\
    denied　{ getattr } for　pid=19029 exe=/usr/sbin/httpd \
    path=/var/www/html/about.html dev=dm-0 ino=373900 \
    scontext=root:system_r:httpd_t tcontext=user_ubject_r:user_home_t \
    tclass=file
    嘿嘿，问题找到了，果然是SELinux的新特性搞的鬼。我把目录或文件设成了user_home_t类型，因此apache的进程没有权限，无法访问。针对Apache的进程所使用的SELinux target policy规定了apache的进程只能访问httpd_sys_content_t类型的目录或文件。
    解决办法：
    很简单，把目录或文件的策略类型改成 httpd_sys_content_t 就可以了
    使用root用户
      `$ chcon -t httpd_sys_content_t 目录名或文件名`
    然后可以用 ls -laZ 命令查看文件目录的策略类型。

 

 2. Mysql - Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (13)
     刚搞定Apache，mySQL又出问题了。
      问题现象：
      本机用mysql命令可以正常登录数据库并正常操作。但是在php写的页面中，不管怎样，连接mySQL数据库时，都会报如下错误：
      Can't connect to local MySQL server through socket　'/var/lib/mysql/mysql.sock' (13)
      问题原因：
      查看mysql.sock文件，存在并且任何人都可读可写。发现avc message (/var/log/messages)中同样有策略错误的记录。
      用 ps -efZ|grep mysql 命令检查mysql的进程，发现mySQL使用了unconfined_t　这个未定义策略类型在运行，而mysql.sock以及mysqld文件的策略类型都是var_lib_t。很明显，这应该是个Fedora Core 3 的 BUG，SELinux target policy的BUG，redhat并没有为mySQL制定正确的target policy。
      解决办法：
      到redhat的bugzilla系统上搜索，果然找到了这个BUG。
      Bug #:　 138421　
      https://bugzilla.redhat.com/bugzill...g.cgi?id=138421
      在这个页面找到新的target policy的补丁安装即可
      补丁下载页面：
      [ftp://people.redhat.com/dwalsh/SELinux/FC3](ftp://people.redhat.com/dwalsh/SELinux/FC3)
      你也可以从本文的附件中下载
      只要下载
      selinux-policy-targeted-1.17.30-2.23以上的版本就能正常使用mySQL了。
      如果你原来的系统安装了 selinux-policy-targeted-source (源代码)，那么你也必需下载source的rpm文件，并首先升级这个包，因为两个包有依赖关系。
      补丁安装办法：

 ```shell
#step1:  使用root用户
#step2: 先升级新的target-policy-source (如果你之前安装了这个包的话)
rpm -Uvh selinux-policy-targeted-sources-1.17.30-2.61.noarch.rpm

#step3: 升级新的target-policy
rpm -Uvh selinux-policy-targeted-1.17.30-2.61.noarch.rpm

#step4: 更新mysql相关的target policy
rpm -q -l mysql-server | restorecon -R -v -f -
rpm -q -l mysql | restorecon -R -v -f -
 
#step5 重起mysql的服务
service mysqld restart
 ```

 

### SSH免密登陆

减少密码传输。

```shell
# 生成公私密钥: 缺省在~/.ssh/下生成 id_rsa, id_rsa.pub
ssh-keygen -t rsa

# 将id_rsa.pub内容复制到目标主机的 ~/.ssh/authorized_keys

# 登陆，将提示信息保存,缺省在~/.ssh/known_hosts
ssh user@host
```



## 2.3  WINDOWS系统安全

一 最常见的windows安全隐患

1)  IPC通道

控制台使用net系列命令. 

 ```shell
 # 以用户名abc进入到ip,使用IPC通道的网络连接
 net use \\ip\ipc$ * /user:abc
 ```



2. 关闭windows的系统报警声 1:13 2012-3-6

法1: 开始－运行－cmd－

```shell
net stop beep  //停掉beep服务
sc config beep start= disabled  //把beep服务设置为禁用状态
```

法2: bios中禁用. ide页设置Halt on 为 All error即可.

 

3. windows/ubuntu双系统下windows重装修复grub 1:13 2012-3-6

用ubuntu的安装光盘进入到试用termianl下，执行以下命令：

```shell
# 查看linux /的sda路径,如/dev/sda7
$sudo fdisk -l 

# 映射mnt
$sudo mount /dev/sda7 /mnt 

# 安装grub
$sudo grub-install --root-directory=/mnt /dev/sda 
```



## 本章参考

[1].  SELinux中的Apache和MySQL设定 http://childman.bokee.com/5077254.html

[2].  https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=13842

[3]. CentOS7使用firewall-cmd打开关闭防火墙与端口 https://blog.csdn.net/s_p_j/article/details/80979450

 

# 3  访问控制技术

Authentication：  认证，关注用户是谁。包括消息认证和身份认证。要验证其真实性。

Authorization：英 [ˌɔ:θəraɪˈzeɪʃn]，美 [ˌɔ:θərəˈzeɪʃn]， 授权，关注用户能做什么。不需要注册，授权使用用户信息访问某项服务。



访问控制技术是一个安全信息系统不可或缺的安全措施，对保护数字资源的安全有着重要意义。访问控制技术起源于20世纪70年代，当时是为了满足管理大型主机系统上共享数据授权访问的需要；基本目标都是防止非法用户进入系统和合法用户对系统资源的非法使用。为了达到这个目标，访问控制常以用户身份认证为前提，在此基础上实施各种访问策略来控制和规范合法用户在系统中的行为。

权限控制的中心是对访问数据的控制。访问控制（也称存取控制）的目的是根据需要批准或禁止用户访问数字资源，确保用户对数据只能进行经过授权的有关操作；使每个用户都能方便地访问其在工作中所需要的数据（根据其责任和资格），同时屏蔽不允许他们访问的数据。

在访问控制机制中，一般把被访问的资源称为“客体”，把以用户名义进行资源访问的进程、事务等实体称为“主体”。因此访问控制的基本目标就是为了限制访问主体（用户、进程、服务等）对访问客体（文件、系统等）的访问权限，从而使计算机系统在合法范围内使用；决定用户能做什么，也决定代表一定用户权益的程序能做什么。

目前，访问控制机制理论有四种：

* 自主访问控制（*Discretionary Access Control*，*DAC*）：通过访问控制列表（*ACL*：*Access Control List*）来实现，如防火墙机制iptables.

* 强制访问控制（*Mandatory Access Control*，*MAC*）：

* 基于角色的访问控制（*Role-based Access Control*，*RBAC*）；

* 使用控制（*Usage Control*，*UCON*）。



## 3.1  基于角色的访问控制RBAC

RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。 *RBAC*属于策略中立的访问控制模型，既可以实现自主存取控制策略（*DAC*），又可以实现强制存取控制策略（*MAC*），可以有效缓解传统安全管理处理瓶颈问题，被认为是一种普通适用的访问控制模型，尤其适用于大型组织的统一资源有效的访问控制机制。

角色（*Role*）作为一个用户与权限的代理层，解耦了权限和用户的关系，所有的授权应该给予角色而不是直接给用户或组（*Group*）。权限是权限颗粒，由操作（*Operation*）和资源（*Resource*）组成，表示对资源的一个操作，即“*Operation + Resource*”；例如，对于新闻的删除操作。角色－权限（*Role-Privilege*）是多对多（*Many-to-Many*）的关系，这是权限的核心。

RBAC参考文献

http://csrc.nist.gov/groups/SNS/rbac/index.html

http://csrc.nist.gov/groups/SNS/rbac/faq.html

 

**RBAC参考模型部件**

*NIST*（*The National Institute of Standards and Technology*，美国国家标准与技术研究院，*2004*）发布标准*RBAC*模型。标准*RBAC*模型由*4*个部件模型组成，这*4*个部件模型分别是：

* 基本模型*RBAC0*（*Core RBAC*）；

* 角色分级模型*RBAC1*（*Hierarchical RBAC*，含*General*，*Limited*）；

* 角色限制模型*RBAC2*（*Constraining RBAC*，含*Static/Dynamic Separation of Duty*，即*SSD*和*DSD*）；

* 统一模型*RBAC3*（*Combines RBAC*）。



**RBAC0**： 基本模型。权限赋予角色，再把角色赋予用户。用户和角色，角色和权限都是多对多的关系。用户拥有的权限等于他所有的角色持有权限之和。在*RBAC0*之中*,*包含最基本的*5*个元素：用户集（*users*，*USERS*）、角色集（*roles*，*ROLES*）、目标*/*对象集（*objects*，*OBS*）、操作集（*operations*，*OPS*）、许可权*/*特权集（*permissions*，*PRMS*）。



**角色分层模型RBAC1**

RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。角色继承用于解决复杂组织机构之间的权限关系。它是一种“很自然地”对组织机构层次中权限和责任的映射。如：总经理→部门经理→业务员。角色继承的方向和用户的关系方向相反，即权限最小的在顶端：业务员→部门经理→总经理。如：若所有*role_salesman*（业务员）的权限都是*role_Mgr*（经理）的权限，那么*role_Mgr*继承自*role_salesman*。



**角色限制模型RBAC2（Constraint RBAC）**

RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。职责关系分离（*SoD*）用于增强利益冲突策略，这种策略某些组织机构可能会需要，即避免用户超出其当前职位合理的权限等级。简单地说，就是避免两个角色间的冲突。如：会计和出纳，在一般公司都不允许同一个人兼任。因此在分配角色的时候，应该禁止这两种角色赋给同一人。

* 静态职责分离SSD：即在系统初始化时，当角色授给用户时来判断是否将冲突的角色给了同一用户。在*RBAC*标准中，冲突的角色被定义为一个二元关系，就是说，任何一个用户只能拥有其中的一个。
* 动态职责分离DSD：指相冲突的角色可以同时给一个，但是在一次会话中不能同时扮演两个冲突的角色。如：在超市*POS*系统中，*ywf*可以是收银员或收银员主管（*ROLE*）。收银员必须经过主管才能打开收银机的抽屉修改某次结账错误。如果收银员角色的一个单独的行为中需要从收银员切换到主管，那么*DSD*要求，这个用户（*USER*）必须先放弃收银员角色；即，当该收银员正在收银时发现错误，必须要先关闭抽屉，然后再次以主管身份打开抽屉才行。



**统一模型RBAC3（Combines RBAC）**

RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。



### 基于RBAC的延展——用户组（租户）

当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。

基于RBAC模型，还可以适当延展，使其更适合我们的产品。譬如增加用户组概念，直接给用户组分配角色，再把用户加入用户组。这样用户除了拥有自身的权限外，还拥有了所属用户组的所有权限。

**举例：**

譬如，我们可以把一个部门看成一个用户组，如销售部，财务部，再给这个部门直接赋予角色，使部门拥有部门权限，这样这个部门的所有用户都有了部门权限。用户组概念可以更方便的给群体用户授权，且不影响用户本来就拥有的角色权限。



### 示例1：Python Django后台管理

数据架构：用户表、角色表、权限表、资源列表

* 用户表 auth_user：账号、姓名、邮箱、添加时间、最后登录时间、账号是否禁止登录
* 角色表auth_group：商品管理员、订单管理员、超级管理员
* 权限表auth_permission：对某一个路由的增删改查权限。路由是指向资源 。
* 资源列表(路径正则) ：资源名称（项目模块名称），资源路径（后台路由）
* 资源分类django_content_type：商品模块、订单模块、营销模块、权限模块、内容模块、其他模块

备注：面向资源编程，一个资源就是一个路由URL。资源根据实际权限控制需要，可以是菜单、视图、模块、操作方法（如增删改查、上传下载）等。



**后端如何判断用户权限?**

1. 用户发送Method + URL
2. 后端首先查询是哪一个用户，然后查询当前用户的角色
3. 判断这个角色是否可以访问此URL对应的方法
4. 如果用户有权限访问此URL就返回数据，不能访问就返回401状态码。



Django自带权限管理是基于角色的权限管理模型。用户 -> 组 -> 权限

django自带表分为二类，

* 一类是auth开头的，需要激活了认证应用auth才生效，这些表是权限管理表，可管理用户、用户组、权限，内容对象。
* 另一类是django开头的表，功能是app管理、会话管理、管理日志、数据迁移记录。

表格 django自带表

| 表名                  | 表字段                                                       | 功能说明     | 备注        |
| --------------------- | ------------------------------------------------------------ | ------------ | ----------- |
| auth_group            | id, name                                                     | 认证组名称   | 创建时空组  |
| auth_group_permission | id, group_id, permission_id                                  | 组和权限关联 |             |
| auth_permission       | id, name, content_type_id, code_name                         | 权限项名称   | 预创建      |
| auth_user             | id, password, last_login, is_superuser,<br/>username, first_name, last_name,email,<br/>is_staff, is_active, date_joined | 认证用户     |             |
| auth_user_groups      | id, user_id, group_id                                        | 用户和组关联 |             |
| django_admin_log      | active_time, object_id, user_id,,,                           | 管理日志     |             |
| django_content_type   | id, app_label, model                                         | 内容对象     | app > model |
| django_migrations     | id, app, name, applied                                       | ORM记录      |             |
| django_session        | session_key, session_date, expire_date                       | 会话管理     |             |



激活认证应用-auth

```python
# /django/
from django.contrib.auth.models import User, Group  

class UserViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows users to be viewed or edited.
    """
    queryset = User.objects.all().order_by('-date_joined')
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
```



创建超级用户 admin（普通用户创建可以通过接口或页面上操作 ）

```shell
python manage.py createsuperuser --email admin@example.com --username admin
```



### 示例2：Python flask_appbuilder后台管理

用户通过角色关联到 若干权限，权限为视图项权限（每个权限可以由二部分组成：权限控制对象，权限控制对象的某个操作形为如can_read）。

* 权限表 permission：规定若干基本权限（此处为操作形为）如读、写、列表、删除...,  
* 视图项 view_menu：页面上每一个要控制权限的项都可以作为一个视图项如数据源页，看板页，图表页甚至数据源某列等等。



表格 flask_appbuilder模块权限管理的数据表 （表名以ab_开头）

| 表名                    | 权限说明           | 字段                                | 权限详述                                                     |
| ----------------------- | ------------------ | ----------------------------------- | ------------------------------------------------------------ |
| ab_role                 | 角色               | id, name(uni)                       | 一个角色映射到访问权限，一个用户可以是多个角色，一个角色也可以有多个用户。6个预创建角色分别是Admin, Alpha, Gramma, granter, Public, sql_lab。 |
| ab_premission           | 权限               | id, name(uni)                       | 操作形为如can list/can del, menu_access等。共85个            |
| ab_view_menu            | 被管对象           | id, name(uni)                       | 权限控制对象即资源包括菜单view、视图menu、数据源，数据集，看板，图板等等.<br>示例数据集：[database_name].[schema] ，[database_name].[schema](id:xx) |
| ab_permission_view      | 权限视图关联       | id, permission_id, view_menu_id     | 建议permission表和view_menu表的关联，多对多关系。            |
| ab_permission_view_role |                    | id, permission_view_id, <br>role_id | 角色对应的视图权限。permission_view_id和role_id二个外键分别对应到ab_permission_view表和ab_role表的主键。 |
| ab_user_role            | user和role关联     | id, user_id, role_id                | 建立user表和role表的关联，多对多关系                         |
| ab_user                 |                    | id, ...                             | 包括用户基本信息，包括用户名/密码等。                        |
| ab_register             | 用户注册时基本信息 | id, ...                             | 如果不允许用户自注册，此表则不用。                           |

备注：权限和被管对象通过表`ab_permission_view`关联起来。



## 3.2  认证

认证技术是计算机网络安全中的一个重要内容，一般可以分为两种:

**（1）消息认证:**用于保证信息的完整性和抗否认性；在很多情况下，用户要确认网上信息是不是假的，信息是否被第三方修改或伪造，这就需要消息认证。消息认证的有关内容参见[加密解密](http://web.nuist.edu.cn/courses/jsjwl/cha9/jmjm.htm)部分和[数字签名](http://web.nuist.edu.cn/courses/jsjwl/cha9/szqm.htm)部分。

**（2）身份认证:**用于鉴别用户身份。包括（1）识别：明确并区分访问者的身份；（2）验证：对访问者声称的身份进行确认。

常见的第三方认证机制有：OpenID、LDAP、Kereros。

 

**问题的来源**

在一个开放的分布式网络环境中，用户通过工作站访问服务器上提供的服务。
* 服务器应能够限制非授权用户的访问并能够认证对服务的请求。
* 工作站不能够被网络服务所信任其能够正确地认定用户，即工作站存在三种威胁。

一个工作站上一个用户可能冒充另一个用户操作；

一个用户可能改变一个工作站的网络地址，从而冒充另一台工作站工作；

一个用户可能窃听他人的信息交换，并用回放攻击获得对一个服务器的访问权或中断服务器的运行。

**所有上述问题可以归结为一个非授权用户能够获得其无权访问的服务或数据。**

 

### 3.2.1 认证机制

#### SASL

SASL（Simple Authentication and Security Layer，简单认证和安全层）是一种用来扩充C/S模式验证能力的机制。在[Postfix](https://baike.baidu.com/item/Postfix/10077421)可以利用SASL来判断用户是否有权使用转发服务，或是辨认谁在使用你的服务器。

SASL支持多种认证方法，主要包括以下几种：
* Anonymous：匿名，无须认证
* PLAIN：最简单也是最危险的机制，信息采用明文密码方式传播。
* DIGEST-MD5：与HTTP Diges兼容的安全机制。
* GSSAPI: Generic Security Services Application Program Interface（通用安全服务应用程序接口），GSSAPI本身是一套API，由IETE标准化。其最主要的实现是基于kerberos。所以一般GSSAPI暗指Kerberos.

 

#### JAAS

​     Java Authentication Authorization Service（JAAS，Java验证和授权API）提供了灵活和可伸缩的机制来保证客户端或服务器端的Java程序。Java早期的安全框架强调的是通过验证代码的来源和作者，保护用户避免受到下载下来的代码的攻击。JAAS强调的是通过验证谁在运行代码以及他/她的权限来保护系统免受用户的攻击。它让你能够将一些标准的安全机制，例如Solaris NIS（[网络信息服务](https://baike.baidu.com/item/网络信息服务)）、Windows NT、LDAP（轻量目录存取协议），Kerberos等通过一种通用的，可配置的方式集成到系统当中去。

​     JAAS已经整合进了Java 2 SDK 1.4，作为标准的[用户认证](https://baike.baidu.com/item/用户认证)与授权模型。

一旦执行代码的用户通过了认证，JAAS授权组件将和核心Java[访问控制](https://baike.baidu.com/item/访问控制)模型一起工作，来保护对敏感资源的访问。

**JAAS核心类和接口**

* JAAS相关的核心类和接口分为三类，公共、认证和授权。
* 公共类：Subject,，Principal，Credential
* 认证类和接口：LoginContext，LoginModule，CallbackHandler，Callback
* 授权类 ：Policy，AuthPermission，PrivateCredentialPermission

详细的描述请参考《JAAS Reference Guide》。

 

范例程序的代码分为两部分，一部分为主程序，执行用户认证过程，

源程序如下(CountFiles.java) ：
```java
package samples;

import javax.security.auth.Subject;
import javax.security.auth.login.LoginContext;
import javax.security.auth.login.LoginException;
import com.sun.security.auth.callback.TextCallbackHandler;
 
public class CountFiles {
  static LoginContext lc = null;
  public static void main(String[] args) {
 
    //使用配置文件中名字为“CountFiles”的条目
    try {
      lc = new LoginContext("CountFiles",
      new TextCallbackHandler());
   } catch (LoginException le) {
     le.printStackTrace();
     System.exit(-1);
   }
 
   try {
     lc.login();
     //如果没有异常抛出，则表示认证成功
   } catch (Exception e) {
     System.out.println("Login failed: " + e);
     System.exit(-1);
   }
 
   //以认证用户的身份执行代码 CountFilesAction.run
   Object o = Subject.doAs(lc.getSubject(), new CountFilesAction());
   System.out.println("User " + lc.getSubject( ) + " found " + o + " files.");
   System.exit(0);
  }
}
```

说明：主程序包含了三个重要的步骤：首先构造一个LoginContext对象，然后使用这个对象进行登录，最后，把用户作为doAs方法一个参数，CountFilesAction为用户想要执行的具体操作。



源程序如下 (CountFilesAction.java) ：

```java
package samples;
 
import java.io.File;
import java.security.PrivilegedAction;
 
class CountFilesAction implements PrivilegedAction {
  public Object run() {
   File f = new File(".");
   File[] files = f.listFiles();
   return new Integer(files.length);
  }
}
```



### 3.2.2 OpenID

OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的[身份认证](https://baike.baidu.com/item/身份认证)。

示例：Google/Yahoo/AOL/Flickr/MyOpenID
```python
# Uncomment to setup OpenID providers example for OpenID authentication
OPENID_PROVIDERS = [
  { 'name': 'Google', 'url': 'https://www.google.com/accounts/o8/id' },
  { 'name': 'Yahoo', 'url': 'https://me.yahoo.com' },
  { 'name': 'AOL', 'url': 'http://openid.aol.com/<username>' },
  { 'name': 'Flickr', 'url': 'http://www.flickr.com/<username>' },
  { 'name': 'MyOpenID', 'url': 'https://www.myopenid.com' }
]
```

### 3.2.3 LDAP

#### 3.2.3.1   目录服务

目录是一个为查询、浏览和搜索而优化的专业分布式数据库，它呈树状结构组织数据，就好象Linux/Unix系统中的文件目录一样。目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。

目录服务是由目录数据库和一套访问协议组成的系统。类似以下的信息适合储存在目录中：
* 企业员工信息，如姓名、电话、邮箱等；
* 公用证书和安全密钥；
* 公司的物理设备信息，如服务器，它的IP地址、存放位置、厂商、购买时间等；

 

表格 2 目录服务软件比较

|                                                              | 简介                                                         | 特性                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| LDAP                                                         | 轻量目录访问协议(Lightweight  Directory Access Protocol)的缩写。基于X.500标准，最新版本3.0 | 支持TCP/IP。  查询快但写慢。  C/S模型，Server 用于存储数据，Client提供操作目录信息树的工具。 |
| X.500                                                        | 构成全球分布式的目录服务系统的协议                           | 严格按照ISO七层协议，较复杂。  主要运行在UNIX系统。          |
| [Active Directory](https://technet.microsoft.com/en-us/library/dd448614.aspx) |                                                              |                                                              |
| [ApacheDS](http://directory.apache.org/apacheds/)            |                                                              |                                                              |

 

#### 3.2.3.2   LDAP简介

Ldap (Lightweight Directory Access Protocol)，轻量目录访问协议，提供被称为目录服务的信息服务，特别是基于x.500（构成全球分布式的目录服务系统的协议）的目录服务。

* Ldap运行在TCP/IP或其他面向连接的传输服务之上。

* Ldap同时是一个IETF标准跟踪协议，在“轻量级目录访问协议(Ldap )技术规范路线图”RFC4510中被指定。

* Ldap软件来源于OpenLDAP项目，该项目是一个由志愿者组成的团队。

表格 3 LDAP协议的版本

|      | 发布时间 | 特性                                                         |
| ---- | -------- | ------------------------------------------------------------ |
| 1.0  | 1993     | 共有四类10种操作：查询类操作，如搜索、比较；更新类操作，如添加条目、删除条目、修改条目、修改条目名；认证类操作，如绑定、解绑定；其它操作，如放弃和扩展操作。 |
| 2.0  |          |                                                              |
| 3.0  | 1997     | 不是一个单一的协议，而是一个协议群组。                       |

说明：

1. LDAP中的安全模型：主要通过身份认证、安全通道和访问控制来实现。

* 身份认证在LDAP中提供三种认证机制，即匿名、基本认证和SASL（Simple Authentication and Secure Layer）认证。
* 通讯安全：LDAP中提供了基于SSL/TLS的通讯安全保障。SSL/TLS是基于PKI信息安全技术，是目前Internet上广泛采用的安全服务。
* 访问控制：LDAP，用户数据管理和访问标识是一体的。基于策略语句来实现的，无论是访问控制的数据对象，还是访问控制的主体对象，均是与这些对象在树中的位置和对象本身的数据特征相关。

**2. LDAP的衍生版本**，有以下三种，皆使用LDAP协议，但后两种使用额外专有信息指定其使用方式。
* ldap://: 一项基本LDAP协议，允许对目录服务进行结构化访问。
* ldaps://: 此衍生版本用于通过SSL/TLS实现LDAP表达。普通LDAP流量未经加密，不过大多数LDAP实现方案支持此功能。这种LDAP连接加密方法实际已经被弃用，建议大家使用STARTTLS作为替代。如果大家在非安全网络上使用LDAP，则强烈建议使用加密机制。
* ldapi://: 用于通过IPC表达LDAP。其通常用于安全接入本地LDAP系统以实现管理用途。其能够内部嵌套而非公开网络端口实现通信。

 

 ![image-20200108002846475](../media/domain/\security_002.png)

 

图 2 LDAP组织数据的方式（DIT~Data Information Tree数据信息树）

说明：树型目录。
1. 条目Entry：也叫记录项，是LDAP中最基本的颗粒，就像字典中的词条，或者是数据库中的记录。通常对LDAP的添加、删除、更改、检索都是以条目为基本对象的。
* DN：Distinguished Name，每一个条目都有一个唯一的标识名。
* Base DN： LDAP目录树的最顶部即根结点，如上图的Base DN="dc=mydomain,dc=org"。
* RDN：一般指DN逗号最左边的部分，特指管理LDAP中信息的最高权限用户。
通过DN的层次型语法结构，可以方便地表示出条目在LDAP树中的位置，通常用于检索。

2. Attribute: 属性，每个条目都可以有很多属性（Attribute），比如常见的人都有姓名、地址、电话等属性。每个属性都有名称及对应的值，属性值可以有单个、多个，比如你有多个邮箱。
3. ObjectClass: 对象类，对象类是属性的集合，通过对象类可以方便的定义条目类型。每个条目可以直接继承多个对象类，这样就继承了各种属性。对象类有三种类型：结构类型（Structural）、抽象类型(Abstract)和辅助类型（Auxiliary）。
* 结构类型是最基本的类型，它规定了对象实体的基本属性，每个条目属于且仅属于一个结构型对象类。
* 抽象类型可以是结构类型或其他抽象类型父类，它将对象属性中共性的部分组织在一起，称为其他类的模板，条目不能直接集成抽象型对象类。
* 辅助类型规定了对象实体的扩展属性。每个条目至少有一个结构性对象类。

 

表格 4 LDAP基本术语

| 概述                   | 别名   | 语法             | 描述                             | 值(举例)                   |
| ---------------------- | ------ | ---------------- | -------------------------------- | -------------------------- |
| commonName             | cn/uid | Directory String | 姓名                             | sean                       |
| surname                | sn     | Directory String | 姓                               | Chow                       |
| organizationalUnitName | ou     | Directory String | 单位（部门）名称                 | IT_SECTION                 |
| organization           | o      | Directory String | 组织（公司）名称                 | example                    |
| telephoneNumber        |        | Telephone Number | 电话号码                         | 110                        |
| owner                  |        | DN               | 该条目拥有者                     | cn=doubao,ou=ops,dc=shuyun |
| jpegPhoto              |        | Binary           | JPEG照片                         |                            |
| objectClass            |        |                  | 对象类                           | organizationalPerson       |
|                        |        |                  |                                  |                            |
| Entry                  | 条目   |                  |                                  |                            |
| Distinguished  Name    | DN     |                  | 每一个条目都有一个唯一的标识名。 |                            |
|                        | DC     |                  | 一条记录所属区域                 |                            |

 

#### 3.2.3.3     LDAP使用 

**LDIF**

LDIF（LDAP Data Interchange Format，数据交换格式）是LDAP数据库信息的一种文本格式，用于数据的导入导出，每行都是“属性: 值”对，见 [openldap ldif格式示例](http://seanlook.com/2015/01/22/openldap_ldif_example/)

 

**LDAP服务端配置**

OpenLDAP(2.4.3x)服务器安装配置方法见 [这里](http://seanlook.com/2015/01/21/openldap-install-guide-ssl/)。

 

**LDAP客户端模块支持**

[PHP](http://lib.csdn.net/base/php)默认并不启用LDAP支持，[php](http://lib.csdn.net/base/php)的LDAP模块依赖于[OpenLDAP](ftp://ftp.openldap.org/pub/OpenLDAP/openldap-release/)或[bind9.net](http://www.bind9.net/download-openldap/)提供的客户端LDAP库，你必须在编译的时候使用 --with-ldap[=DIR] 才行，如果你想要SASL支持，那还必须使用 --with-ldap-sasl[=DIR] 选项，而且你的系统中必须有 sasl.h 头文件才行。

 

**LDAP客户端访问**

LDAP中也是利用登陆名和密码进行验证，LDAP中会定义一个属性password，用来存放用户密码，而登陆名使用较多的都是mail地址。那怎么样才能正确的用LDAP进行身份验证呢，下面是一个正确而又通用的**步骤**（五大步基于LDAP的一个 “两次绑定” 验证方法）：

说明：绑定有两种，即WEB服务器的用户绑定和请求用户的绑定。实际使用中可只需一次绑定即用户的绑定（如支持匿名绑定搜索）。
1. 从客户端得到登陆名和密码。注意这里的登陆名和密码一开始并没有被用到。
2. bind：先匿名绑定bind到LDAP服务器，如果LDAP服务器没有启用匿名绑定，一般会提供一个默认的用户，用这个进行绑定即可。（若绑定失败，即可认定LDAP验证失败）
3. search搜索：，当上一步绑定成功以后，需要执行一个搜索，而filter就是用登陆名来构造，形如： "(|(uid=$login)(mail=$login))" ，这里的login就是登陆名。搜索执行完毕后，需要对结果进行判断，如果只返回一个entry，这个就是包含了该用户信息的entry，可以得到该entry的DN，后面使用。如果返回不止一个或者没有返回，说明用户名输入有误，应该退出验证并返回错误信息。（可将搜索返回的信息作为注册用户信息）
4. 再次bind用户：上一步执行时得到了用户信息所在的entry的DN，这里就需要用这个DN和第一步中得到的password重新绑定LDAP服务器。
5. bind用户结果的处理：如果能成功绑定，那么就说明验证成功，如果不行，则应该返回密码错误的信息。

 

### 3.2.4 Kerberos

Kerberos这一名词来源于希腊神话“三个头的狗——地狱之门守护者”，后来沿用作为安全认证的概念，该系统设计上采用客户端/服务器结构与DES、AES等加密技术，并且能够进行相互认证，即客户端和服务器端均可对对方进行身份认证。
可以用于防止窃听、防止replay攻击、保护数据完整性等场合，是一种应用对称密钥体制进行密钥管理的系统。

Kerberos提供一个中心认证服务器，提供用户到服务器和服务器到用户的认证服务。



#### 原理篇

**概念**
* Principal：任何服务器所提供的用户、计算机、服务都将被定义成Principal。
* Instances：用于服务principals和特殊管理Principal。
* Realms：Kerberos安装提供的独特的域的控制，把它想象成你的主机和用户所属的主机或者组。官方约定这域需要大写。默认的，Ubuntu将把DNS域名转换为大写当成这里的域。
* Ticket Granting Ticket (TGT)：票据授权票据。用于应用程序与KDC服务器建立安全会话的票据TGT，TGT存在有效期。当TGT失效后，需要重新建立与KDC的安全会话，会话有效期在24小时，不可配置。TGT由认证服务器（AS）签发，TGT使用用户的密码加密，这个密码只有用户和KDC知道。
* 服务票据(ST- Service Ticket)：用于应用程序与服务端建立安全会话的票据，服务票据存在有效期，当服务票据失效后，应用侧需要重新建立与服务端的安全会话。默认有效期为5分钟，不可配置。
* Tickets：确认两个Principal的身份。一个主体是用户，另一个是由用户请求的服务。门票会建立一个加密密钥，用于在身份验证会话中的安全通信。
* Keytab Files：从KDC主数据库中提取的文件，并且包含的服务或主机的加密密钥。

**服务器**

* Key Distribution Center (KDC)：密钥分发中心。KDC由三部分组成，一是principal数据库，认证服务器，和票据授予服务器。每个Realm至少要有一个。

* Ticket Granting Server: (TGS) ：票据授权服务器。根据请求签发服务的票据。
* AS：认证服务器。

总得来讲就是，一个域至少包含一个KDC，最好能有更多的冗余，它包含一个principal数据库。当用户登录一个被Kerberos认证定义的工作站中，KDC发布一个TGT。如果用户提供的证书匹配，用户得到认证，之后就能从TGS请求被kerberos注册过的服务的票据，用户凭票据就可以认证并访问服务，而不需要再提供用户名和密码。

备注：Kerberos是一个时间敏感的协议。因此，如果客户机和服务器之间的本地系统时间超过五分钟（默认情况下），工作站将无法进行身份验证。要纠正这个问题，所有的主机都应该把自己的时间与统一一个（NTP）服务器同步。

 ![kerberos认证原理](..\media\domain\security_015.png)

图 kerberos认证原理

step1&2:  KRB_AS_REQ & KRB_AS_REP,  客户端到AS的 认证请求和响应。验证用户是否合法。

step3&4:  KRB_TGS_REQ & KRB_TGS_REP,  客户端到TGS的 认证请求和响应。获取票据授权票据TGT。

step5&6:  KRB_AP_REQ & KRB_AP_REP,  客户端到AP服务端的 认证请求和响应。验证TGT票据是否合法。



Kerberos采用传统加密算法（无公钥体制DES）。

C/S环境下三种可能的安全方案

* 相信每一个单独的客户工作站可以保证对其用户的识别，并依赖于每一个服务器强制实施一个基于用户标识的安全策略。 (基于用户标识的识别)
* 要求客户端系统将它们自己向服务器作身份认证，但相信客户端系统负责对其用户的识别。
* 要求每一个用户对每一个服务证明其标识身份，同样要求服务器向客户端证明其标识身份。

Kerberos支持以上三种策略。总体方案是提供一个可信第三方的认证服务。

**方案的详细描述：**

**1)一次签名：**

第一次首先需要证书的实体将自己的信息和公钥提交给CA，CA确认该组织的可信赖之后，就用自己的密钥对该实体的信息和公钥进行签名。最后被签名的信息会就叫证书。

**2)二次签名**

用户首先接到一个证书，然后根据CA（可信）提供的公钥进行解密。解密后再由用户发服务许可。

 

#### 用户篇

```sh
$ sudo apt-get install krb5-kdc krb5-admin-server
# 配置，设置ACL权限
$ sudo dpkg-reconfigure krb5-kdc
$ vi /etc/krb5.conf

$ vi /etc/krb5kdc/kdc.conf

$ vi /etc/krb5kdc/kadm5.ac

$ sudo service krb5-admin-server restart

# 设置证书
$ kinit steve/admin

# 查看
$ klist
```



### 3.2.5  JWT - JSON Web Token

 

### 3.2.6 数字签名

在金融和商业等系统中，许多业务都要求在单据上进行签名或加盖印章，证实其真实性，以备日后检查，可是在利用计算机网络来传送报文时，显然不能用手签的方法，在计算机中我们可以采用数字签名的方法，利用公开密钥来实现数字签名，从而代替传统的签名。

  为使数字签名能代替传统的签名，必须满足下面三个条件：

  （1）接收者能够核实发送者对报文的签名；

  （2）发送者事后不能抵赖对其报文的签名；

  （3）接收者无法伪造对报文的签名。

 

​     数字签名操作具体过程如下：首先是生成被签名的电子文件（《电子签名法》中称数据电文），然后对电子文件用散列算法做数字摘要，再对数字摘要用签名私钥做非对称加密，即作数字签名；之后是将以上的签名和电子文件原文以及签名证书的公钥加在一起进行封装，形成签名结果发送给收方，待收方验证。

数字签名验证过程：接收方收到数字签名的结果，其中包括数字签名、电子原文和发方公钥(C/S模式中服务器方公钥通常已经知道)，接收方进行签名验证。验证过程是：接收方首先用发方公钥解密数字签名，导出数字摘要，并对电子文件原文做同样散列算法得出一个新的数字摘要；将两个摘要进行结果比较，结果相同则签名得到验证，否则签名无效。这就做到了《电子签名法》中所要求的对签名不能改动，对签署的内容和形式也不能改动的要求。

### 3.2.7  基于证书的认证

近年来相当流行的认证技术应该是基于证书的认证。其实证书就是一个数据块，主要包括公开密钥、主体相关的信息、证书有效的日期、证书发行者的信息和证书发行者生成的签名。

其实整个过程很简单，我就认为是二次数字签名就是了。第一次首先需要证书的实体将自己的信息和公钥提交给CA，CA确认该组织的可信赖之后，就用自己的密钥对该实体的信息和公钥进行签名。最后被签名的信息会就叫证书。站在用户的角度，用户首先接到一个证书，当然会根据CA（可信）提供的公钥进行解密，如果能解密，当然就可以获得可信赖的信息和实体公钥。然后由实体公钥再进行前面我们介绍的数字签名解密步骤。

 

Pegasus 中基于 SSL 的数据传输流程（协商加密方式为例）如下图所示：
 **Pegasus中基于SSL的数据传输流程**
  ![image-20200108002918380](../media/domain/\security_003.png)

 

## 3.3  授权

### 3.3.1 OAuth

OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAuth是安全的。oAuth是Open Authorization的简写。

表格 5 oAuth版本史

| 版本      | 简介                                                         | 说明                                              |
| --------- | ------------------------------------------------------------ | ------------------------------------------------- |
| OAuth 1.0 | OAuth Core 1.0 版本发布于2007年12月4日，由于存在可被会话定向攻击(session fixation attack)的缘故，2009年6月24日发布了OAuth Core 1.0 Revision A 版本。最终在2010年4月，OAuth成为了RFC标准： RFC 5849: The OAuth 1.0 Protocol。 | OAuth的标准版本涉及三步流程，分别要访问三个URL。  |
| OAuth 2.0 | 2010年5月初在IETF发布草案。OAuth 2.0是OAuth协议的下一版本，但不[向后兼容](https://baike.baidu.com/item/向后兼容)OAuth  1.0。 OAuth 2.0关注客户端开发者的简易性，同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。 | OAuth 2.0简化开发，流程中去除涉及用户授权的环节。 |

备注：3-Legged OAuth就是通过User的授权，Consumer可以访问User在Service Provider的数据；至于2-Legged OAuth，没有User的参与，只是Consumer和Service Provider的交互。

 

一个典型的OAuth应用通常包括三种角色，分别是：
* Consumer：消费方
* Service Provider：服务提供者
* User：用户

消费方如果想使用服务提供者的OAuth功能，通常需要先申请两样东西：
* Consumer Key
* Consumer Secret



**OAuth 1.0**

OAuth认证授权就三个步骤：

1. 获取未授权的Request Token。

2. 获取用户授权的Request Token。

3. 用授权的Request Token换取Access Token

上面三步分别对应于三个URL：Request Token URL、User Authorization URL 和 Access Token URL。

 ![image-20200108003001319](../media/domain/\security_004.png)

图 3 OAuth流程

说明：
* A：消费方请求Request Token
* B：服务提供者授权Request Token
* C：消费方定向用户到服务提供者
* D：获得用户授权后，服务提供者定向用户到消费方
* E：消费方请求Access Token
* F：服务提供者授权Access Token
* G：消费方访问受保护的资源

 

**OAuth 2.0**

OAuth 2.0定义了四种授权方式。
* 授权码模式（authorization code）
* 简化模式（implicit）
* 密码模式（resource owner password credentials）
* 客户端模式（client credentials）

> 备注：在API市场的API授权管理使用中， 消费者key常指appid，消费者secret指静态token。通过静态token获取动态token，动态token验证是否过期、是否已授权（若未授权需要在API市场订阅，订阅过程会获取提供方的授权token）。



**示例：twitter/google/azure**

https://raw.githubusercontent.com/dpgaspar/Flask-AppBuilder/master/examples/oauth/config.py
```python
OAUTH_PROVIDERS = [
  {'name':'twitter', 'icon':'fa-twitter',
    'remote_app': {
      'consumer_key': os.environ.get('TWITTER_KEY'),
      'consumer_secret': os.environ.get('TWITTER_SECRET'),
      'base_url': 'https://api.twitter.com/1.1/',
      'request_token_url': 'https://api.twitter.com/oauth/request_token',
      'access_token_url': 'https://api.twitter.com/oauth/access_token',
      'authorize_url': 'https://api.twitter.com/oauth/authenticate'}
  },
  {'name': 'google', 'icon': 'fa-google', 'token_key': 'access_token',
    'remote_app': {
      'consumer_key': os.environ.get('GOOGLE_KEY'),
      'consumer_secret': os.environ.get('GOOGLE_SECRET'),
      'base_url': 'https://www.googleapis.com/oauth2/v2/',
      'request_token_params': {
       'scope': 'email profile'
      },
      'request_token_url': None,
      'access_token_url': 'https://accounts.google.com/o/oauth2/token',
      'authorize_url': 'https://accounts.google.com/o/oauth2/auth'}
  },
  {'name': 'azure', 'icon': 'fa-windows', 'token_key': 'access_token',
    'remote_app': {
      'consumer_key': os.environ.get('AZURE_APPLICATION_ID'),
      'consumer_secret': os.environ.get('AZURE_SECRET'),
      'base_url': 'https://login.microsoftonline.com/{AZURE_TENANT_ID}/oauth2',
      'request_token_params': {
       'scope': 'User.read name preferred_username email profile',
       'resource' : os.environ.get('AZURE_APPLICATION_ID'),
      },
      'request_token_url': None,
           'access_token_url':'https://login.microsoftonline.com/{AZURE_TENANT_ID}/oauth2/token',
  'authorize_url':'https://login.microsoftonline.com/{AZURE_TENANT_ID}/oauth2/authorize'}
  }
]
# OAuth 2.0去除了用户鉴权步骤，即 request_token_url=None
```


## 3.4  HTTPS

### 3.4.1 HTTPS原理

HTTPS 区别于 HTTP，它多了加密(encryption)，认证(verification)，鉴定(identification)。它的安全源自非对称加密以及第三方的 CA 认证。

 ![image-20200108003018914](../media/domain/\security_005.png)

图 4 HTTPS的运作方式

如上图所示，简述如下：
* 客户端生成一个随机数 random-client，传到服务器端（Say Hello)
* 服务器端生成一个随机数 random-server，和着公钥，一起回馈给客户端（I got it)
* 客户端收到的东西原封不动，加上 premaster secret（通过 random-client、random-server 经过一定算法生成的东西），再一次送给服务器端，这次传过去的东西会使用公钥加密
* 服务器端先使用私钥解密，拿到 premaster secret，此时客户端和服务器端都拥有了三个要素：random-client、random-server 和 premaster secret
* 此时安全通道已经建立，以后的交流都会校检上面的三个要素通过算法算出的 session key

 

### 3.4.2 证书

CA 认证分为三类：DV ( domain validation)，OV ( organization validation)，EV ( extended validation)，证书申请难度从前往后递增，貌似 EV 这种不仅仅是有钱就可以申请的。

两个发放免费 CA 的机构：StartSSL 和 CAcert。

 

**StartSSL**

StartSSL 隶属于一家以色列商业公司 [StartCOM](http://www.startcom.org/)，是 StartCom Linux 操作系统的生产供应商。由 StartCom 提供的大多数解决方案都基于开源技术和开放标准。StartCom 自 2005 年开始经营 StartCom 认证机构（StartCOM CA），即由 StartSSL 负责运营。StartSSL已于2016年被 WoSign（一家中国 CA，2002年成立）收购。因隐瞒了收购同行的主导权与架构的转移，伪造SHA-1凭证的分发日期，2017年先后被Mozilla、苹果和谷歌封锁。沃通([WoSign](https://buy.wosign.com/)/WoTrus)自2017年9月26日起不再提供在线申请免费电子邮件加密证书的服务，但仍提供免费SSL证书。

 

**CAcert**

[CAcert.org](http://www.cacert.org/) 是一个社区驱动的安全证书颁发机构，2003年7月注册成立于澳大利亚新南威尔士州。从 2005年10月开始提供 Class 1 和 Class 3 根证书（Root Certificate），Class 3 证书是 Class 1 的具有更高安全性的分支。

 

### 3.4.3 自签名证书

#### 3.4.3.1   自签名证书的生成

对于一般的小型网站尤其是博客，可以使用自签名证书来构建安全网络，所谓自签名证书，就是自己扮演 CA 机构，自己给自己的服务器颁发证书。

第一步，为服务器端和客户端准备公钥、私钥
```sh
# 生成服务器端私钥
openssl genrsa -out server.key 1024
# 生成服务器端公钥
openssl rsa -in server.key -pubout -out server.pem
 
# 生成客户端私钥
openssl genrsa -out client.key 1024
# 生成客户端公钥
openssl rsa -in client.key -pubout -out client.pem
```



第二步，生成 CA 证书

```shell
# 生成 CA 私钥
openssl genrsa -out ca.key 1024
# X.509 Certificate Signing Request (CSR) Management.
openssl req -new -key ca.key -out ca.csr
# X.509 Certificate Data Management.
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

说明：第二步要手工填写一些数据，如Common Name (e.g. server FQDN or YOUR name)

 

第三步，生成服务器端证书和客户端证书
```sh
# 服务器端需要向 CA 机构申请签名证书，在申请签名证书之前依然是创建自己的 CSR 文件
$ openssl req -new -key server.key -out server.csr
# 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书
$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt
 
# client 端
$openssl req -new -key client.key -out client.csr
# client 端到 CA 签名
$openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt
```


最后生成的文件如下：
```sh
.
├── https-client.js
├── https-server.js
└── keys
├── ca.crt
├── ca.csr
├── ca.key
├── ca.pem
├── ca.srl
├── client.crt
├── client.csr
├── client.key
├── client.pem
├── server.crt
├── server.csr
├── server.key
└── server.pem
```




#### 3.4.3.2     Chrome配置信任自签名证书

备注：修改后都需要重启浏览器才生效。证书后缀名为crt或cer。
1. 本地证书
chrome://flags/#allow-insecure-localhost

将此值改为Enabled，即可允许访问localhost/127.0.0.1之类的本地主机自签名。

 

2. 非本地证书

1) 从浏览器客户端 导出证书，步骤为：‘查看证书’--> 导出

2) 导入证书到chrome，步骤如下：

证书管理 --> 选择保存位置为‘受信任的根证书颁发机构’

 

### 3.4.4 本节参考

[1].   HTTPS证书生成原理和部署细节 https://www.cnblogs.com/liyulong1982/p/6106129.html

[2].   Google Chrome安装证书的方法_百度经验 https://jingyan.baidu.com/article/c843ea0bc4142a77921e4a79.html

[3].   wosign  https://buy.wosign.com/ 

[4].   腾讯HTTPS性能优化实践 https://baijiahao.baidu.com/s?id=1559840813865463 

 

## 3.5  相关技术

### 3.5.1 随机数、序列号和时间戳

会话session区分常用方法有三种：随机数、序列号和时间戳。

|          | 时间戳 | 序列号 | 随机数                                                       |
| -------- | ------ | ------ | ------------------------------------------------------------ |
| 简介     |        |        | 一般应用于其它两种不能用的场景。  慎用伪随机数。             |
| 优点     |        |        |                                                              |
| 缺点     |        |        | UDP非连接不好用。                                            |
| 应用场景 |        |        | 验证码生成，抽奖活动，UUID生成，SessionID生成，Token生成，CSRF Token，找回密码Token，游戏(随机元素的生成)，洗牌，俄罗斯方块出现特定形状的序列，游戏爆装备，<br>密码应用场景，生成密钥：对称密码，消息认证，生成密钥对：公钥密码，数字签名，生成IV： 用于分组密码的CBC，CFB和OFB模式，生成nonce: 用于防御重放攻击; 分组密码的CTR模式，生成盐：用于基于口令的密码PBE等 |

 

**随机数**

随机数分为真随机数和伪随机数，我们程序使用的基本都是伪随机数，其中伪随机又分为强伪随机数和弱伪随机数。

真随机数，通过物理实验得出，比如掷钱币、骰子、转轮、使用电子元件的噪音、核裂变等

伪随机数，通过一定算法和种子得出。软件实现的是伪随机数。
* 强伪随机数，难以预测的随机数
* 弱伪随机数，易于预测的随机数

 

随机数有3个特性，具体如下：
* 随机性：不存在统计学偏差，是完全杂乱的数列
* 不可预测性：不能从过去的数列推测出下一个出现的数
* 不可重现性：除非将数列本身保存下来，否则不能重现相同的数列

 

### 3.5.2 加密解密

详见 另文《算法分析与设计》、《软件加密方案》

 

数据加密是所有数据安全技术的核心，在计算机网络环境下很难做到对敏感性数据的隔离，较现实的方法是设法做到即使攻击者获得了数据，但仍无法理解其包含的意义，以便达到了保密的目的。

**原理**：在发送端将数据变换成某种难以理解的形式，并在接收端进行反变换，以恢复数据的原样。加密/解密的关键是：加密/解密算法的提出和加密/解密模块的实现。

**密钥**：一串参与加密的字符串，算法在密钥的控制下进行操作，对应不同的密钥，相同的算法和相同的明文可以产生完全不同的密文。从而密钥可以充分地发挥已设计的加密算法的作用。

 

## 3.6  案例

### 3.6.1 MAZE的信用卡机制

由于每个Peer都要同时与多个服务器通讯，我们采用了一种类似信用卡机制的分布式认证算法，来确保用户身份认证的安全性和有效性。参考Kerberos机制，我们有信用卡发放机构(TGS: Ticket Grant Server)，称之为用户管理服务器，由它进行用户注册和发放信用卡。用户持有效的信用卡访问其他的服务器，其他的服务器检查信用卡上的数字签名来验证身份，判断是否允许进行某项操作。一个正常的从注册到登录的流程如下：

![image-20200108003228403](../media/domain/\security_006.png)                      

图3 分布式认证机制

 

1. Peer首先登录到用户管理服务器，申请一个Maze UID账号，申请时把登录密码保存在用户管理服务器上。

2. 账户申请完毕之后，Peer向用户管理服务器请求这个Maze账户的身份认证数据包，同时提交自己的Maze服务端口、自己看到的本地IP地址。

3. 用户管理服务器在身份认证数据包中记录Peer的Maze UID、从用户管理服务器看到的外部IP、Maze服务端口、是否在局域网内（根据Peer提交的自己看到本地IP和心跳服务器看到Peer的外部IP是否一致判断）、用户级别、信用卡失效时间等信息，用系统签名私钥密码对数据包进行数字签名，把整个数据包和其数字签名（我们把它称之为信用卡）用Peer的登录密码进行加密，把加密后的证书返回给Peer。整个算法可以用下列公式表示：

 ```sh
Certificate = Maze ID + IPoutside + Portservice + InGatewayOrNo + Level + ExpireTime …
Ticket = Certificate + Sign system-private-key (Certificate)
EncryptedTicket = Ecrypt peer-password (Ticket)
 ```



4. 如果用户在Peer端有正确的登录密码，就可以把加密的数据包解密，从而获得有数字签名的信用卡。

`Ticket = Decrypt peer-password (EncryptedTicket)`

5. 当Peer需要访问其他的服务器（如心跳服务器等）时，出示这个信用卡，服务器用系统签名公钥密码检查数字签名是否正确，以及是否已经过期，如果检查失败，要求Peer重新申请新的信用卡，否则允许下一步操作，也就是登录成功。

 

这种基于信用卡机制的分布式身份认证算法，可以保证用户密码只在注册初期出现，此后并不在网上明文传送；系统签名密码则只在用户管理服务器上出现，因而从客户端很难破解，这些方法都保证了用户身份认证的安全性。

 

**总结：**

​     用户注册时，经过了1次摘要，1次非对称加密，1次对称加密： 1)用户服务器生成证书(注：证书的组成Certificate = Maze ID + IPoutside + Portservice + InGatewayOrNo + Level + ExpireTime)，2)然后对证书作数字签名(数字签名过程：由证书得到数字摘要，然后对数字摘要进行非对称加密，私钥由用户服务器自己保存，形成数字签名(Sign system-private-key (Certificate))，3)对Certificate+数字签名= Ticket用peer密码进行对称加密。最后将这个加密Ticket发送回客户端。

​    用户登陆时，向服务器发出请求，服务器返回EncryptedTicket。用户则用登陆密码对EncryptedTicket进行解密，如果解密成功，就能得到证书+数字签名。用服务器的公钥就能验证是否来自服务器，登陆成功。

 

## 本章参考

参考网站

* MIT Doc官方网址：http://web.mit.edu/kerberos/krb5-latest/doc/index.html
* OpenLdap官方网址：http://www.openldap.org 



**参考链接**

* SASL https://baike.baidu.com/item/sasl/5292142

* JAAS  https://baike.baidu.com/item/JAAS

* JAAS基础 https://www.aliyun.com/jiaocheng/344430.html 

* oAuth  https://baike.baidu.com/item/oAuth

* LDAP  https://baike.baidu.com/item/LDAP 

* 认证和 授权(Authentication和Authorization) https://www.cnblogs.com/jiaoxh/p/5531528.html

* LDAP服务器的概念和原理简单介绍https://www.cnblogs.com/yjd_hycf_space/p/7994597.html

* [LDAP基础概念](http://407711169.blog.51cto.com/6616996/1439623)

* [LDAP-HOWTO](http://www.tldp.org/HOWTO/LDAP-HOWTO/ldapbackends.html)

* [openldap doc admin24](http://www.openldap.org/doc/admin24/) http://www.openldap.org/doc/admin24/

* RBAC权限管理模型：基本模型及角色模型解析及举例 www.woshipm.com/pd/440765.html

* RBAC权限模型——项目实战 https://blog.csdn.net/zwk626542417/article/details/46726491

* 理解OAuth 2.0 http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

* 微博开放接口与企业平台整合的设计与实现http://www.doc88.com/p-4834172007596.html



 

# 4  安全编程
* 代码审视 code review：编码规范、安全审视
* 安全工具：codex安全云

## 4.1  内存管理

对于内存管理程序。程序员可能犯的错误是：
* 释放一个内存块但继续引用其中的内容；(delete xxx; xxx=NULL;)
* 分配一个内存块并使用其中未经初始化的内容；(memset)
* 调用realloc对一个内存块进行扩展，因此原来的内容发生了存储位置的变化，但程序引用的仍是原来存储位置的内容；
* 分配一个内存块后即“失去”了它，因为没有保存指向所分配内存块的指针；
* 读写操作越过了所分配内存块的边界；
* 没有对错误情况进行检查。(返回值判断)

 

EG: 复制一个不重叠的内存块

memcpy
```c
//用预编译符号来分隔DEBUG与RELEASE版本,做到臃肿缓慢与整洁快速的融合,通常DEBUG时使用有额外检查的版本
void* memcpy(void* pvTo, void* pvFrom, size_t size)
{
  void* pbTo = (byte*)pvTo;
  void* pbFrom = (byte*)pvFrom;
  #ifdef DEBUG
  if(pvTo == NULL | | pvFrom == NULL)
  {
    fprintf(stderr, “Bad args in memcpy\n”);
    abort();
  }
  #endif
  while(size-->0)
    *pbTo++ == *pbFrom++;
  return(pvTo);
}
```



## 4.2  安全编程实践

### 4.2.1 使用断言进行防止错误

上面memcpy那段深着色的额外检索可用下面简单断言来替换,

`assert(pvTo != NULL && pvFrom != NULL);`

assert的实现就是宏,因此可以定义自己的断言函数,比如出了错误继续运行,只是把错误记录下来,这是预防性编程.

## 4.3  语言相关的安全编码

### 4.3.1 net中使用安全函数

strcpy-->strcpy_s

xxx-->xxx_s

 

### 4.3.2 PHP代码执行漏洞

**代码执行函数**

PHP中可以执行代码的函数。如eval()、assert()、system()、exec()、shell_exec()、passthru()、 escapeshellcmd()、pcntl_exec() 等

 

**文件包含代码注射**

文件包含函数在特定条件下的代码注射，如include()、include_once()、 require()、require_once()。

当allow_url_include=On ，PHP Version>=5.2.0 时，导致代码注射。

include.php
```php
<?php
include($_GET[‘a’]);
?>
```
URL： [http://localhost/test/ include.php?a=data:text/plain,%3C?php%20phpinfo();?%3E](http://localhost/test/include.php?a=data:text/plain,)

 

**正则匹配代码注射**

众所周知的preg_replace()函数导致的代码注射。当pattern中存在/e模式修饰符，即允许执行代码。这里我们分三种情况讨论下

1 ). preg_replace() pattern 参数注射

pattern即第一个参数的代码注射。
 当magic_quotes_gpc=Off时，导致代码执行。

demo code 3.1:
preg_replace1.php
```php
<?php
 echo $regexp = $_GET[‘reg’];
 $var = ‘<php>phpinfo()</php>’;
 preg_replace(“/<php>(.*?)$regexp”, ‘\1’, $var);
 ?>
```
URL：preg_replace1.php?reg=%3C/php%3E/e

 

2 ). preg_replace() replacement参数注射

replacement即第二个参数的代码注射，导致代码执行。

3 ). preg_replace()第三个参数注射

我们通过构造subject参数执行代码。

 

# 5  安全算法 

详见 《[非数值和工业界领域算法](../algo/非数值和工业界领域算法.md)》

​      

# 6  安全架构

 

# 7  业界范例

## 7.1  华为的安全白皮书

### 7.1.1 概述

 ![image-20200108003335514](../media/domain/\security_007.png)

图 5 华为整体流程框架

 

### 7.1.2 IPD流程

 ![image-20200108003352743](../media/domain/\security_008.png)

图 6 华为的安全融入IPD流程

 

 ![image-20200108003408254](../media/domain/\security_009.png)

图 7 华为集成产品开发流程IPD的软件部分



 ![image-20200108003424138](../media/domain/\security_011.png)

图 8 华为硬件的正向和逆向可追溯图示

 

### 7.1.3 信息安全
* 信息安全维度：权限、设备、人员、奖惩
* 安全级别：外部公开、内部公开、秘密、机密、绝密
* BUG级别：严重、一般和提示。
* 安全违规级别：从1~4，危险度依次降低。

 

# 8  黑客技术

## 8.1  黑客的攻击思路

 ![image-20200108003443793](../media/domain/\security_012.png)

图  黑客的攻击思路与操作图

 

### 8.1.1 黑客常用工具

| 工具类型                 | 工具列表                                                     |
| ------------------------ | ------------------------------------------------------------ |
| 信息收集工具         | Ø Whois   Ø Ping  Ø Traceroute   Ø Nslookup   Ø 网站公布信息<br>Ø 服务器市场信息[http://www.netcraft.com](http://www.netcraft.com/)    Ø 域名登记信息[http://www.internic.com](http://www.internic.com/)    <br>Ø 扫描器之王-NMAP  Ø 漏洞检查利器－NESSUS  Ø 大范围扫描工具－ X-SCAN  <br>Ø 常用扫描工具－　SHADOW SCAN、CIS、SUPERSCAN和HOLESCAN等。  Ø Neotrc20－图形化的Trace杂项工具,生动地显示出各节点和路由    Ø [http://visualroute.visualware.com](http://visualroute.visualware.com/) |
| 漏洞挖掘工具         | SNIFFER工具  Ø 常见免费的SNIFFER－－ tcpdump、 Windump、 SNIFFIT、NETXRAY  <br/>口令窃听工具  Ø  dsniff   密码破解工具  Ø WINDOWS密码导出工具－－ PWDDUMP  Ø WINDOWS密码破解工具－－ L0phtCrack   <br>Ø 大众型破解2000/Nt的小工具－－NtKill   <br/>其他工具  Ø IDA、W32dasm－　<br/>优秀的反汇编工具  Ø Softice、Trw2000　－优秀的调试工具 |
| UNIX日志清除工具 | 日志文件：WTMP, UTMP,  lastlog, messages, secure, xferlog, maillog, warn, mail, access_log,  error_log，sulog   <br/>工具：wipe |
| Windows 2000 日志清除    | 清除安全日志：`$ elsave -s \\IDS_ONE -l "Security" -C`  <br/>清除应用程序日志：`$elsave -s \\IDS_ONE -l "Application" -C` <br/>清除系统日志： `$ elsave -s \\IDS_ONE -l "System"  -C` |



**弱点挖掘**

目的：进入系统或者直接攻击.利用这些网络服务固有的或配置上的漏洞，试图从目标系统上取回重要信息（如口令文件）、或在上面执行命令

方法：
* 匹配公开弱点知识库
* 查询匹配弱点的网页
* 弱口令字典库

 

### 8.1.2 常见安全隐患

**Windows十大安全隐患**
* Web服务器和服务
* 工作站服务
* Windows远程访问服务
* 微软SQL服务器
* Windows认证
* Web浏览器　　
* 文件共享
* LSASS Exposures
* 电子邮件客户端
* 即时信息

 

**Unix十大安全隐患**
* BIND域名系统
* Web服务器
* 认证
* 版本控制系统
* 电子邮件传输服务
* 简单网络管理协议
* 开放安全连接通讯层
* 企业服务NIS/NFS 配置不当
* 数据库
* 内核

 

## 8.2  SQL注入

[   ](http://images.cnblogs.com/cnblogs_com/hkncd/201203/201203310307276110.png)![image-20200108003514123](../media/domain/\security_013.png)

**示例：Name、Password、Corp**

 

**1.初级注入--绕过验证，直接登录**

输入：`' or 1=1--'`

SQL：

```sql
SELECT * From Table WHERE Name='SQL inject' and Password='' and Corp='' or 1=1--'
```

说明：从代码可以看出，前一半单引号被闭合，后一半单引号被 “--”给注释掉，中间多了一个永远成立的条件“1=1”，这就造成任何字符都能成功登录的结果。而Sql注入的危害却不仅仅是匿名登录。

 

**2.中级注入--借助异常获取信息**

输入：`' or 1=(SELECT @@version) –-`

SQL：

```sqlite
SELECT * From Table WHERE Name='SQL inject' and Password='' and Corp='' or 1=(SELECT @@VERSION)--'
```

说明：判断条件变成了 1=(SELECT @@VERSION),这个写法肯定会导致错误，但出错正是我们想要的。点击登录后，页面出现以下信息：

Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2008 (SP3) - 10.0.5500.0 (X64) Sep 21 2011 22:45:45 Copyright (c) 1988-2008 Microsoft Corporation Developer Edition (64-bit) on Windows NT 6.1 <X64> (Build 7601: Service Pack 1) ' to data type int.

可怕的事情出现了，服务器的操作系统和SQL Server版本信息竟然通过错误显示出来。

备注：phpmyadmin中执行select * from anchor where 1=(SELECT @@VERSION)无结果显示，可能此BUG已修复。

 

**3.危害扩大--获取服务器所有的库名、表名、字段名**

**输入**：

SQL：

```sql
b' or 1=(SELECT top 1 name FROM master..sysobjects where xtype='U' and name not in (SELECT top 1 name FROM master..sysobjects where xtype='U'))
```

说明：

 

**常见SQL命令：**
* SELECT @@VERSION：显示MySQL数据库版本。



### 8.2.1 SQL注入安全问题

概念：所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
 危害：
 1. 查询数据库中敏感信息。

 2. 绕过认证。

 3. 添加、删除、修改服务器数据。

 4. 拒绝服务。?id=(BENCHMARK(100000000, MD5(RAND()));
 例子：
    `$sql = “SELECT name FROM users WHERE id = ‘”. $_GET[‘id’] . “‘”;`
    当ID值为：1’or 1=’1 SQL语句 (已测试可以注入)：

```sql
 SELECT name FROM users WHERE id = ‘1’ or 1=’1 ‘
```

  说明：1=1的时候，条件语句WHEREOR之前的不起作用。 ‘的作用是组装SQL语句。
  解决方法：
  SQL组装的时候，对外部变量以及所有变量都进行过滤：
  PHPWIND中，可以用sqlEscape、sqlImplode、sqlSingle、sqlMulti等函数过滤组装。过滤主要是一些’单引号这些可以破坏SQL组装的数据。

```php
/**
 * SQL组装-私有SQL过滤
 * @param string $val 过滤的值
 * @param int  $iskey 0-过滤value值，1-过滤字段
 * @return string
 */
 private function build_escape_single($val, $iskey = 0) {
   if ($iskey === 0) {
     if (is_numeric($val)) {
       return ” ‘” . $val . “‘ “;
     } else {
       return ” ‘” . addslashes(stripslashes($val)) . “‘ “;
     }
   } else {
     $val = str_replace(array(‘`’, ‘ ‘), ”, $val);
     return ‘ `’.addslashes(stripslashes($val)).’` ‘;
   }
 }
```

## 8.3  浏览器安全和隐私

https是安全浏览。

 

### 8.3.1 Cookie和session机制

Cookie和session机制涉及到一些用户隐私： 如浏览习惯，用户名，密码。

Cookie存在客户端，session存在服务器端。

 

**cookie安全设置
** 解决：
 cookie httponly flag ： 在用到用户名登陆密码之类的安全性比较高的cookie的时候，可以在cookie中设置httponly属性，该属性只允许php等访问cookie，而不允许js访问。
 cookie secure flag ： 在涉及到https这样的情况，需要对cookie加密传输，那么可以设置这个属性

 **session安全 **
 1. SESSION是保存在服务器端的，具有比COOKIE一定的安全性。
 2. 使用COOKIE的时候，如果长时间没有动作，可以设置一个时间值，来对COOKIE进行过期。
 3. 尽量让用户每次的cookie值都是不同的，这样可以保证cookie被盗取也不能长期使用的问题

 

#### 8.3.1.1     Cookie

**Cookie**，有时也用其复数形式[Cookies](http://baike.baidu.com/subview/1311/6319629.htm)，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于RFC2109和2965都已废弃，最新取代的规范是RFC6265[1] 。（可以叫做浏览器缓存）

Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入jsessionid，这样服务器 可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。

Cookie的安全级别包括组织所用Cookie，接受所有Cookie，中级，和高级。

 

**应用**：登陆、购物车等等。

**原理**：浏览器缓存。

**流程**：客户端请求-服务器响应-响应数据保存

COOKIE**组成**：Expires, Name, Value等等。

Cookie攻击

建议开发人员在向客户端 Cookie 输出敏感的内容时（譬如：该内容能识别用户身份）：

​     1）设置该 Cookie 不能被脚本读取，这样在一定程度上解决上述问题。
 　2）对 Cookie 内容进行加密，在加密前嵌入时间戳，保证每次加密后的密文都不一样（并且可以防止消息重放）。
 　3）客户端请求时，每次或定时更新 Cookie 内容（即：基于第2小条，重新加密）
 　4）每次向 Cookie 写入时间戳，数据库需要记录最后一次时间戳（防止 Cookie 篡改，或重放攻击）。
 　5）客户端提交 Cookie 时，先解密然后校验时间戳，时间戳若小于数据数据库中记录，即意味发生攻击。

基于上述建议，即使 Cookie 被窃取，却因 Cookie 被随机更新，且内容无规律性，攻击者无法加以利用。另外利用了时间戳另一大好处就是防止 Cookie 篡改或重放。

**Cookie窃取**：搜集用户cookie并发给攻击者的黑客。攻击者将利用cookie信息通过合法手段进入用户帐户。

**Cookie篡改**：利用安全机制，攻击者加入代码从而改写 Cookie 内容，以便持续攻击。

 

**Cookie的传递流程**

适用对象：中级读者

当在浏览器地址栏中键入了[Amazon](http://baike.baidu.com/view/552703.htm)的URL，浏览器会向Amazon发送一个读取网页的请求，并将结果在显示器上显示。这时该网页在你的电脑上寻找Amazon网站设置的Cookie文件，如果找到，浏览器会把Cookie文件中的数据连同前面输入的URL一同发送到Amazon[服务器](http://baike.baidu.com/view/899.htm)。 服务器收到Cookie数据，就会在他的数据库中检索你的ID，你的购物记录、个人喜好等信息，并记录下新的内容，增加到数据库和Cookie文件中去。 如果没有检测到Cookie或者你的Cookie信息与数据库中的信息不符合，则说明你是第一次浏览该网站，服务器的CGI程序将为你创建新的ID信息， 并保存到数据库中。

Cookie是利用了[网页代码](http://baike.baidu.com/view/59513.htm)中的HTTP头信息进行传递的，浏览器的每一次网页请求，都可以伴随Cookie传递，例如，浏览器的打开或刷新网页操作。服务器将Cookie添加到网页的[HTTP](http://baike.baidu.com/view/9472.htm)头 信息中，伴随网页数据传回到你的浏览器，浏览器会根据你电脑中的Cookie设置选择是否保存这些数据。如果浏览器不允许Cookie保存，则关掉浏览器 后，这些数据就消失。Cookie在电脑上保存的时间是不一样的，这些都是由服务器的设置不同决定的。Cookie有一个Expires（有效期）属性， 这个属性决定了Cookie的保存时间，服务器可以通过设定Expires字段的数值，来改变Cookie的保存时间。如果不设置该属性，那么 Cookie只在浏览网页期间有效，关闭浏览器，这些Cookie自动消失，绝大多数网站属于这种情况。通常情况下，Cookie包含Server、 Expires、Name、value这几个字段，其中对服务器有用的只是Name和value字段，Expires等字段的内容仅仅是为了告诉浏览器如 何处理这些Cookies。

 

**Cookie的编程实现**

适用对象：高级读者

多数[网页编程语言](http://baike.baidu.com/view/162447.htm)都提供了对Cookie的支持。如[javascript](http://baike.baidu.com/view/16168.htm)、[VBScript](http://baike.baidu.com/view/24920.htm)、[Delphi](http://baike.baidu.com/view/3297.htm)、[ASP](http://baike.baidu.com/view/2616.htm)、[SQL](http://baike.baidu.com/view/34.htm)、[PHP](http://baike.baidu.com/subview/99/5828265.htm)、C#等。在这些[面向对象](http://baike.baidu.com/view/125370.htm)的编程语言中，对Cookie的编程利用基本上是相似的，大体过程为：先创建一个Cookie对象（Object），然后利用控制函数对Cookie进行赋值、读取、写入等操作。那么如何通过代码来获取其他用户Cookie中的敏感信息，下面进行简单的介绍。

该方法主要有两步，首先要定位你需要收集Cookie的网站，并对其进行分析，并构造URL；然后编制收集Cookie的PHP代码，并将其放到你可以控制的网站上，当不知情者单击了你构造的URL后可以执行该PHP代码。下面我们看具体的实现过程。

 

#### 8.3.1.2     Session

Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。

 

具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到关闭这个网站所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中我们可以看到，Session实际上是一个特定的时间概念。

需要注意的是，一个Session的概念需要包括特定的客户端，特定的[服务器](http://baike.baidu.com/view/899.htm)端以及不中断的操作时间。A用户和C服务器建立连接时所处的Session同B用户和C服务器建立连接时所处的Session是两个不同的Session。

session的工作原理

（1）当一个session第一次被启用时，一个唯一的标识被存储于本地的cookie中。

（2）首先使用session_start()函数，[PHP](http://baike.baidu.com/subview/99/5828265.htm)从session仓库中加载已经存储的session变量。

（3）当执行PHP脚本时，通过使用session_register()函数注册session变量。

（4）当PHP脚本执行结束时，未被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php.ini文件中的session.save_path指定，下次浏览网页时可以加载使用。

 

Session解决方案，就是要提供在PHP脚本中定义全局变量的方法，使得这个全局变量在同一个Session中对于所有的PHP脚本都有效。上面我们提到了，Session不是一个简单的时间概念，一个Session中还包括了特定的用户和[服务器](http://baike.baidu.com/view/899.htm)。因此更详细地讲，在一个Session定义的全局变量的作用范围，是指这个Session所对应的用户所访问的所有PHP。

 

### 8.3.2 浏览器模拟登陆

带refer：常被用来分辨是否spider。

带cookie：

带proxy：

 

method: get/post

有些需要随机数random和令牌token支持。

 

## 8.4  网站攻击

### 8.4.1 XSS跨站脚本

**概念**：XSS (Cross Site Scripting，跨站脚本攻击)  是Web程序中最常见的漏洞。恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。


**危害：**
* 盗取用户COOKIE信息。
* 跳转到钓鱼网站。
* 操作受害者的浏览器，查看受害者网页浏览信息等。
* 蠕虫攻击。

**描述**：反射型跨站。GET或POST内容未过滤，可以提交JS以及HTML等恶意代码。
**代码**：

```php
<?php echo $_GET[‘msg’]; ?>
 //正常URL
 user.php?msg=henhao
 //带JS的URL
 user.php?msg=<script>alert(1)</script>
 //恶意跳转URL
 user.php?msg=<script>window.history.back(-1);</script>
```

 **解决方法**：输出过滤，php端输出到view的模板页面上的数据都需要经过过滤：

```php+HTML
// 输出过滤HTML JS标签
$var = str_replace(array(‘<iframe’,'<meta’,'<script’), ”, $var); $var = str_replace(array(‘..’,’)’,'<‘,’=’), array(‘..’,’)’,'<‘,’=’), $var); 
$var = addslashes($var); 
```




### 8.4.2 CSRF跨站攻击

**概念**：CSRF（Cross-site request forgery，跨站请求伪造），也被称成为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用，伪造请求，冒充用户在站内的正常操作。

XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用 受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。


**危害**：强迫受害者的浏览器向一个易受攻击的Web应用程序发送请求，最后达到攻击者所需要的操作行为。
 例子：
 <img src=“http://www.2cto.com /addfriend.php?id=123”/> 
 1. 上面是一个图片的html标签，但是src中是一个添加id为123好友的新增好友链接。
 2. 恶意用户可以将这段代码植入其它网站网页上面，甚至可以img设置为0,0，让用户不知不觉中点击这个链接，达到用户并不像加这个人好友，但是添加的目的。
 3. 当很多人都无意加了id为123这个人为好友的时候，id为123的恶意用户就有权限来查看这些人的信息，甚至可以发送很多恶意的信息，达到恶意用户的目的。

**解决方法**：

1. http://www.2cto.com/addfriend.php?id=123 关键操作只接受POST请求。

 2. 验证码：CSRF攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。

但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。

3. 检测 Referer。Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。
4. Token：目前主流的做法是使用 Token 抵御 CSRF 攻击。每次用户登录网站随机生成一个token，存放在cookie中，用户的所有操作中都需要经过token验证。

 

### 8.4.3 flash安全问题

例子： `http://images.sohu.com/bill/s2010/liulin/nokia/1602600902.swf?clickthru=javascript:alert(1)`

**解决方法** ：
在网站根目录中，添加crossdomain.xml文件，这个文件主要是控制flash的域访问。
淘宝的：http://www.taobao.com/crossdomain.xml

 ```xml
 <?xml version=”1.0″ ?> 
 <cross-domain-policy> 
 <allow-access-from domain=”*.taobao.com” /> 
 <allow-access-from domain=”*.taobao.net” /> 
 <allow-access-from domain=”*.taobaocdn.com” /> 
 <allow-access-from domain=”*.tbcdn.cn” /> 
 <allow-access-from domain=”*.allyes.com” /> 
 </cross-domain-policy> 
 ```



### 8.4.4 XML注入安全问题

**概念**：和SQL注入原理一样，XML是存储数据的地方，如果在查询或修改时，如果没有做转义，直接输入或输出数据，都将导致XML注入漏洞。攻击者可以修改XML数据格式，增加新的XML节点，对数据处理流程产生影响。
**危害**：

 1. 攻击者可以新增XML节点
 2. 破坏原来的XML结构，影响业务流程，甚至产生严重的错误。
 例子：
```php
$xml = “<USER role=guest><name>“ . $_GET[‘name’] . “</name><email>“ . $_GET[‘email’] . “</email></USER>”;
```
 需要得到的XML结构：
```xml
<?xml version=”1.0″ encoding=”UTF-8″?>  
 <USER role=guest> 
 <name>user1</name> 
 <email>user1@a.com</email> 
 </USER> 
```
恶意代码：
`user1@a.com</email></USER><USER role=admin><name>test</name><email>user2@a.com`

意外的XML文档：

```xml
<?xml version=”1.0″ encoding=”UTF-8″?> 
 <USER role=guest> 
 <name>user1</name> 
 <email>user1@a.com</email> 
 </USER> 
 <USER role=admin> 
 <name>test</name> 
 <email>user2@a.com</email> 
 </USER> 
```



**解决方法：**

 1. 对php处理XML文档的时候，进行标签过滤
 2. 尽量减少直接被外部访问到xml文档，可以采用文件名用散列方法等。



### 8.4.5 其它漏洞

1. **url跳转漏洞**
    概念：Web应用程序接收到用户提交的URL参数后，没有对参数做”可信任URL”的验证，就向用户浏览器返回跳转到该URL的指令。
    危害：钓鱼网站
    例子： `http://m.yahoo.cn/log.php?c=web&u=http://www.163.com`
    解决方法：
    对跳转的php函数进行进一步优化，使页面跳转可以在可信任的范围内。 例如可以有跳转域名白名单方法，这个访问各大公司使用比较多

2. **文件系统跨越漏洞
** 概念：对文件目录参数没有进行过滤，导致恶意用户可以通过在参数中输入一些执行命令，或者跨越访问的行为，来超出用户的访问权限。
 例子：通过一个或多个../跨越目录限制

```php
$fp = fopen(“image/{$_GET[‘filename’]}”, ‘r’);
Getfile?filename=../../../../etc/passwd
```

解决方法：1)对文本操作的时候一定要谨慎，不可信任; 2)严格使用phpwind中安全类库escapePath函数

3. **系统命令漏洞**
   概念：用户提交的参数用于执行系统命令的参数。
    解决：1)谨慎使用系统命令，对使用系统命令的地方需要进行安全评审; 2)对命令语句进行严格过滤

4. **文件上传漏洞
   ** 概念：Web应用程序在处理用户上传的文件时，没有判断文件的扩展名是否在允许的范围内，或者没检测文件内容的合法性，就把文件保存在服务器上，甚至上传脚本木马到web服务器上，直接控制web服务器。
    情况：

```shell
  1. 未限制扩展名
  2. 未检查文件内容
  3. 病毒文件
     解决方法：
  4. 使用安全的，可信任的上传组件。
  5. 检查文件扩展名，保证文件的类型正确。
  6. 检查文件内容，保证用户不伪造文件类型。
```



5. **任意文件下载漏洞**
    解决方法：
    1). Apache虚拟目录指向
    2). Java/PHP读取文件



6. **权限控制漏洞**
    概念：属于业务逻辑上的安全管理。
    访问控制：

* 水平访问：Web应用程序接收到用户请求，修改某条数据时，没有判断数据的所属人，或判断数据所属人时，从用户提交的request参数（用户可控数据）中，获取了数据所属人id，导致恶意攻击者可以通过变换数据ID，或变换所属人id，修改不属于自己的数据。

* 垂直访问：由于web应用程序没有做权限控制，或仅仅在菜单上做了权限控制，导致的恶意用户只要猜测其他管理页面的URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升目的。
  **存在情况**：

- URL级别的。（例如论坛需要操作评分的时候，有一个提交的URL地址，该地址提交过去，如果不做权限判断，那么恶意用户就可以随意的拿这个URL地址来进行恶意行为）
- 菜单级别。（会员中心或者后台管理中心，会有菜单，管理员可以看到多个功能，普通管理员只能看到一部分功能。但是如果你对管理员操作的功能区不做权限判断，那么普通管理员只要猜测或者获取管理区的URL，就可以进行管理员操作了）
  
```shell
危害：属于业务逻辑的漏洞，这些危害性是巨大的，可以让普通用户就可能获取管理员的权限，对网站进行恶意破坏或者做非法行为。
解决方案：
  1项目先期，做一份详细的权限规划文档。
  2在开发中严格按照权限文档的要求去做权限。
  3后期测试需要覆盖权限这一块功能区。
  4程序员需要经常注意这些方面的要求。
```



## 本章参考

[1].  PHP开发web应用安全总结 http://www.cnseay.com/386/

[2].  PYTHON操作MYSQL时防止SQL注入 blog.csdn.net/pi9nc/article/details/17631905 

[3]. nmap参考指南：http://insecure.org/nmap/man/zh/index.html

[4]. John the Ripper文档:http://www.openwall.com/john/doc/

[5]. tcpdump手册：http://www.tcpdump.org/tcpdump_man.html

[6].  cookie http://baike.baidu.com/subview/835/5062332.htm

[7].  session http://baike.baidu.com/view/25258.htm





# 源码保护

## Java源码保护



## python源码保护

方法一(入门级):  源码py 到 字节码 pyc 的转化, windows环境生成的文件在`__pycache__`目录.

```shell
# 编译: 依赖模块 py_compile 或 compileall
$ python -m py_compile *.py

# 反编译: 依赖模块 uncompile
$ uncompyle6 xx.cpython-38.pyc > xx.py
```



方法二: 代码混淆, 通过变量名替换等方法 让代码变得难读.  常用混淆库有**pyobfuscate**, pyminifier

```sh
$ pip install pyminifier
$ pyminifier --nonlatin --replacement-length=10 -O xx.py

# 或者 base64编码 + lzma加密
$ pyminifier --lzma "xx.py"
import lzma, base64
exec(lzma.decompress(base64.b64decode('/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4AC9AIddADSbSme4Ujxz0DHnfZG4YVh3r9CsdtAwW4DRCnyvCgYFNNvit5ucVyZEXm0xrZQFnMmnv5z9aXgGq8oGWLMz+nFaI+A7zI5M115jvtlkHe2PTQ44cNNJgVhXoX718yXUd9RQuI13Z9g+nUZiG4oGdJRmK7JehLK/UQ2Tic8JFOCKT4lM8+hv4AAAZj5170QAhWgAAaMBvgEAALPN0p2xxGf7AgAAAAAEWVo=')))
# Created by pyminifier (https://github.com/liftoff/pyminifier)
```



方法三: .pyd或.so加密

使用cpython,  将 `.py`/`.pyx` 编译为 `.c` 文件，再将 `.c` 文件编译为 `.so`(Unix) 或 `.pyd`(Windows)

```sh
# 在dist目录得到 pyd文件
$ pip install jmpy3
$ jmpy -i "XX.py" -m 0
```

可能问题: 若代码版本不支持在cpython, 兼容成本较大.



方法四:  订制python解释器



其它方法: 使用py2exe(只选用于windows), 第三方包



## 本章参考

* [高级应用 (virbox.com)](https://h.virbox.com/virboxlm/高级应用-1902089.html)
* python代码加密——编译与反编译方法总结 https://blog.csdn.net/submarineas/article/details/93723421?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control
* 如何防止你的代码被窃取？Python代码加密方案汇总（带实例验证） https://blog.csdn.net/weixin_43207777/article/details/108351862
* Python源码寻宝记——地图篇 https://www.lightxue.com/python-internals-locate-source-code



# 附录

## 安全大事记

### 互联网安全大事记

表格 20 8.1互联网安全大事记列表

| 时间 | 国际事件                                                     | 国内事件                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 2011 |                                                              | 2011年底，CSDN中文IT社区、天涯等众多互联网公司的账户密码信息被公开下载（CSDN94万行，密码非明文加密传输)。  <br>国家互联网应急中心通过公开渠道获得疑似泄露的数据库有26个，涉及账号、密码2.78亿条。这些信息均为黑客攻击商业网站后窃取并泄露。 |
| 2012 |                                                              | 2012-2-9，国内主流电商淘宝、当当网、1号店等B2C网站用户个人信息泄露。 |
|      |                                                              | 2012-7，京东商城、当当网、1号店等多家电商网站再次“集体”被曝账户信息泄露。 |
|      |                                                              | 2012-11，包括EMS在内10余家主流快递企业的快递单号信息被大面积泄露，并衍生出多个专门从事快递单号信息交易的网站。 |
| 2013 | 2013.6.5，“[棱镜门](http://baike.baidu.com/subview/10688863/10901700.htm)”事件爆发 [美国国家安全局](http://baike.baidu.com/subview/14954/14954.htm)监控用户隐私。 |                                                              |
| 2014 |                                                              | 2014-5，小米论坛800万用户数据库泄漏。800万行1.3GB，数据项仅username/email/passwd/ip，密码非明文加密保存。<br>2014-8-2，名为“XX神器”的手机病毒开始通过网络大面积传播。上百万手机在半天内受到感染。病毒会向受感染用户手机的通信录自动群发短信，诱骗其他用户点击，该病毒会将短信记录转发至某固定手机号码，获取个人隐私和网银短信验证码等。 |
|      | 微软2014年停止对Windows XP安全更新 。<br>[比特币](http://baike.baidu.com/subview/5784548/12216829.htm)席卷全球诈骗案件频发。 | 国家互联网应急中心（CNCERT）共接收境内网络安全事件报告30684起，较2012年增长71.2%。 |
| 2018 |                                                              |                                                              |
| 2019 |                                                              |                                                              |

 

**2013年全球十大互联网安全事件：**

1. 2013.6.5，“[棱镜门](http://baike.baidu.com/subview/10688863/10901700.htm)”事件爆发 [美国国家安全局](http://baike.baidu.com/subview/14954/14954.htm)监控用户隐私。

2.  微软2014年停止对Windows XP安全更新 。

3. [比特币](http://baike.baidu.com/subview/5784548/12216829.htm)席卷全球诈骗案件频发。

4. [BlackHat](http://baike.baidu.com/subview/2904516/2904516.htm) ([黑帽](http://baike.baidu.com/subview/1231085/1231085.htm)大会)和Defcon (国际黑客大会)在[拉斯维加斯](http://baike.baidu.com/subview/7637/19033395.htm)召开。

5. 韩国政府等多家网站多次爆发大规模的[黑客攻击](http://baike.baidu.com/subview/54848/54848.htm)，瘫痪数小时；

6. 2013.12.7，[Google](http://baike.baidu.com/subview/105/105.htm)曝法国伪造CA证书全球首例国家级伪造CA证书劫持加密通讯事件诞生

7. 2013.3.1，[美国银行](http://baike.baidu.com/subview/788853/788853.htm)、彭博社等金融机构重要资料遭黑客曝光；

8. Apple、Facebook 、Twitter 等科技巨头相继被入侵，用户数据泄漏等事件。

9. 2013.7.23, 思科27亿美元收购网络安全公司Sourcefire 巨头掀起收购安全公司热潮.

10. 五年历史大规模网络间谍活动“红色十月行动”曝光.

 

### 黑客史 

**黑客起源背景：**

起源地：美国

精神支柱：对技术的渴求；对自由的渴求

历史背景：
* 越战与反战活动
* 马丁·路德金与自由
* 嬉皮士与非主流文化
* 电话飞客与计算机革命

 

表格 21 著名黑客列表

| 人物/标题     | 主要事件                                                     | 影响                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 凯文•米特尼克 | 凯文•米特尼克是美国20世纪最著名的黑客之一，他是《社会工程学》的创始人。  <BR>1979，凯文•米特尼克和他的伙伴侵入了北美防空指挥部。 | 1983年的电影《战争游戏》演绎了同样的故事，在片中，以凯文为原型的少年黑客几乎引发了第三次世界大战。 |
| 蠕虫<br/>病毒 | 1988年，莫里斯蠕虫病毒震撼了整个世界。由原本寂寂无名的大学生罗伯特·莫里斯制造的这个蠕虫病毒入侵了大约6000个大学和军事机构的计算机，使之瘫痪。<BR>2001年8月，“红色代码”蠕虫利用微软web服务器IIS 4.0或5.0中index服务的安全缺陷，攻破目的机器，并通过自动扫描感染方式传播蠕虫，已在互联网上大规模泛滥。<BR>2003年，“冲击波”蠕虫。 | 此后，从CIH到美丽杀病毒，从尼姆达到红色代码，病毒、蠕虫的发展愈演愈烈。 |
| 中国黑客      | 1998年印尼事件.<BR >1999年南联盟事件<BR>绿色兵团南北分拆事件<BR>中美五一黑客大战事件 |                                                              |
| 俄罗斯        |                                                              |                                                              |

 

### 信息安全发展史

网络安全敏感国家：美国、加拿大、新西兰、澳大利亚、俄罗斯、台湾、越南、印度和欧洲区（38国）

| 阶段          | 详述                                                         |
| ------------- | ------------------------------------------------------------ |
| 通信保密      | 香农《通信保密系统的信息理论》，  <BR>主要威胁形式：搭线窃听和密码学分析  <br>关心对象：军方和政府 |
| 信息安全      | 操作系统/数据库/网络安全TCSEC-》计算机安全IPSEC-》信息安全CC |
| 信息保障      | 保护和防御信息及信息系统，确保其可用性、完整性、保密性、  鉴别、不可否认性等特性。这包括在信息系统中融入保护、检测、反应功能，并提供信息系统的恢复功能。－－美国国防部令S-3600.1 |
| 数据<br/>安全 | 1998年英国颁布的《数据保护法案》规定，政府采集与公民自身或企业有关的信息，必须遵守资料保护的[法律](https://baike.baidu.com/item/法律)与相关程序，尽量减少重复收集，维护资料的安全，确保信息收集行为的合法性、收集目的的正当性、收集过程的科学性、信息内容的正确性、数据的完整性和准确性。除了部分涉及国家安全、[商业机密](https://baike.baidu.com/item/商业机密/5702583)或[个人隐私](https://baike.baidu.com/item/个人隐私/7128166)的信息受到法律规范而不得公开外，其它政府信息应经过系统的处理后，尽量以电子化形式予以公开。  <br>2016.4，欧盟通过最新《数据保护法》。 |

 

## 信息网络安全资源

中文站点
* 安全焦点：http://www.xfocus.net/
* 绿盟科技：http://www.nsfocus.net/

英文站点
* SecurityFocus：http://www.securityfocus.net/
* PacketStorm:http://packetstormsecurity.org/
* Sysinternals：http://www.sysinternals.net/
* Cert:http:// www.cert.org

 

**安全相关法律法规**

1、《计算机信息网络国际联网安全保护管理办法》

2、中华人民共和国计算机信息系统安全保护条例

3、《互联网上网服务营业场所管理条例》

4、《关于维护互联网安全的决定》

5、《中华人民共和国保守国家秘密法》

 

## 网络安全工具

**扫描器---nmap**

```sh
 Usage: nmap [Scan Type(s)] [Options] <host or net list>
 -sS TCP SYN stealth port scan (default if privileged (root))
 -sT TCP connect() port scan (default for unprivileged users)
 -sU UDP port scan
 -sP ping scan (Find any reachable machines)
 -P0 Don't ping hosts 
 -O Use TCP/IP fingerprinting to guess remote operating system
 -v Verbose.
 -o <logfile> Output scan logs to <logfile>
 -p <range> ports to scan. Example range: 1-1024,1080,6666,31337
```

 例子： `$ nmap -sS -p 21,23,53,80 -O -v [www.yourserver.com] `



**密码破解---John the Ripper**

```sh
 Usage: john-386 [OPTIONS] [PASSWORD-FILES]
 --wordlist=FILE --stdin wordlist mode, read words from FILE or stdin
 --restore[=NAME] restore an interrupted session [called NAME]
 --show show cracked passwords
 --test perform a benchmark
```

解密过程中可以使用Ctrl+C键中止，下次可以从断点继续，所有已破解的密码保存在john.pot文件中，进度文件名默认为restore。

 

**嗅探器---tcpdump**
tcpdump快速入门手册: http://tcpdump.anheng.com.cn/news/22/591.html

  

## 参考资料

* 2013年国际十大互联网安全事件 http://baike.baidu.com/view/11799241.htm 

 

