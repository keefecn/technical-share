| 序号 | 修改时间   | 修改内容                                                     | 修改人 | 审稿人 |
| ---- | ---------- | ------------------------------------------------------------ | ------ | ------ |
| 1    | 2016-10-21 | 创建                                                         | Keefe | Keefe |
| 2    | 2016-12-22 | 增加WEB信息管理章节                                          | 同上   |        |
| 3    | 2018-3-28  | 重新组织目录结构，将运维内容单独成文。<br>补充docker/jenkins章节。 | 同上   |        |
| 4    | 2018-5-24  | 将网站整体优化章节迁移到《网站架构设计和开发》               | 同上   |        |
| 5    | 2019-4-1   | 更新容器部署章节                                            | 同上   |        |
|      |            |                                                              |        |        |









---

# 目录

[TOC]

目录

[目录... 1](#_Toc19744423)

[1   运维概述... 3](#_Toc19744424)

[2   运维技术篇... 3](#_Toc19744425)

[2.1   运维技术方向... 3](#_Toc19744426)

[2.2   硬件基础... 4](#_Toc19744427)

[2.2.1    CPU架构... 4](#_Toc19744428)

[2.2.2    存储介质... 4](#_Toc19744429)

[2.3   系统监控... 7](#_Toc19744430)

[2.3.1    监控指标... 7](#_Toc19744431)

[2.3.2    Linux环境监控IO性能... 7](#_Toc19744432)

[2.4   性能 Performance. 9](#_Toc19744433)

[2.4.1    性能指标... 9](#_Toc19744434)

[2.4.2    类unix系统性能监控命令... 11](#_Toc19744435)

[2.4.3    在线服务故障排查... 13](#_Toc19744436)

[2.4.4    性能压测工具... 14](#_Toc19744437)

[2.4.5    本节参考... 15](#_Toc19744438)

[2.5   高可用性HA. 16](#_Toc19744439)

[2.5.1    SLA协议... 16](#_Toc19744440)

[2.5.2    keepalive实现高可用... 17](#_Toc19744441)

[2.6   CICD持续集成-持续部署... 20](#_Toc19744442)

[2.7   服务集群管理... 20](#_Toc19744443)

[2.8   网站整体优化... 21](#_Toc19744444)

[2.9   本章参考... 21](#_Toc19744445)

[3   运维工具篇... 21](#_Toc19744446)

[3.1   运维工具列表... 21](#_Toc19744447)

[3.2   常用工具与镜像... 23](#_Toc19744448)

[3.2.1    VirtualBox. 23](#_Toc19744449)

[3.2.2    Vagrant. 23](#_Toc19744450)

[3.2.3    容器docker. 26](#_Toc19744451)

[3.2.4    容器编排 K8S. 26](#_Toc19744452)

[3.3   持续集成CI工具：Jenkins. 26](#_Toc19744453)

[3.3.1    安装篇... 26](#_Toc19744454)

[3.3.2    本节参考... 27](#_Toc19744455)

[3.4   Devops工具：TFS. 27](#_Toc19744456)

[3.5   自动化运维工具... 28](#_Toc19744457)

[3.5.1    Ansible. 29](#_Toc19744458)

[3.5.2    Puppet. 29](#_Toc19744459)

[3.5.3    Saltstack. 31](#_Toc19744460)

[3.5.4    fabric. 31](#_Toc19744461)

[3.5.5    本章参考... 32](#_Toc19744462)

[3.6   运维工具选型... 32](#_Toc19744463)

[3.7   本章参考... 32](#_Toc19744464)

[4   Hadoop集群运维... 32](#_Toc19744465)

[5   参考资料... 32](#_Toc19744466)

[5.1   参考书目... 32](#_Toc19744467)

[5.2   参考链接... 33](#_Toc19744468)

[5.3   运维相关的国际会议... 33](#_Toc19744469)







**表目录**

[表格 1 存储介质对比__ 4](#_Toc19744470)

[表格 2 知名服务系统吞吐量列表__ 10](#_Toc19744471)

[表格 3 性能压测工具简介__ 14](#_Toc19744472)

[表格 4 性能压测工具比较__ 15](#_Toc19744473)

[表格 5 每日构建与发布流程列表__ 20](#_Toc19744474)

[表格 6运维项及运维工具列表__ 21](#_Toc19744475)

[表格 7 轻量级运维（系统工具）列表__ 22](#_Toc19744476)

[表格 8 轻量级运维（系统工具）详述__ 22](#_Toc19744477)

[表格 9 常用工具镜像源__ 23](#_Toc19744478)

[表格 11 自动化运维工具比较列表__ 28](#_Toc19744479)







---

# 1  运维概述

运维发展史

人工阶段 -- 工具和自动化阶段 -- 平台化 -- AIOPs（智能运维2016~）



**运维**：运行维护，Operation and maintenance，服务要正常运转。

**运营**：Operation，服务要运转好。

**SRE**：Site Reliability Engineer (网站可靠性工程师)。起源于google，在国内他们被称为运维工程师(OPS,operations)，直接掌管着互联网公司的机器和服务，保证网站不宕机是他们的使命。



​    运维，这里指互联网运维，通常属于技术部门，与[研发](https://baike.baidu.com/item/研发)、[测试](https://baike.baidu.com/item/测试/112688)、[系统管理](https://baike.baidu.com/item/系统管理)同为互联网产品技术支撑的4大部门，这个划分在国内和国外以及大小公司间都会多少有一些不同。

​    一个互联网产品的生成一般经历的过程是：产品经理、需求分析、研发部门开发、测试部门测试、运维部门部署发布以及长期的运行维护。运维的职责覆盖了产品从设计到发布、运行维护、变更升级及至下线的生命周期。



**业务运维工程师的日常工作包括：**
* 监控线上的服务质量
* 响应异常/处理突发故障
* 在线发布/升级产品
* 和相应产品线的研发和测试协调处理产品问题
* 基于工作中的问题和数据分析进行抽取，将运维经验理念落地沉淀为方法论/工具/系统/平台，并制定相关的改进计划，在各个技术方向上落地实现，最终反馈回运维工作中，提高运维本身的效率和产品的价值。



# 2  运维技术篇

## 2.1 运维技术方向

产品的整个生命周期里运维的职责重要而广泛，但运维工程师们的职责不仅限于这部分工作，还需要总结工作中遇到的问题，抽取出相关的技术方向、研发相关的工具和平台以支持/优化业务的发展并提高运维的效率，相关技术工作主要包括：
* 服务监控技术：包括监控平台的研发、应用，服务监控准确性、实时性、全面性的保障
* 服务故障管理：包括服务的故障预案设计，预案的自动化执行，故障的总结并反馈到产品/系统的设计层面进行优化以提高产品的稳定性
* 服务容量管理：测量服务的容量，规划服务的机房建设，扩容、迁移等工作
* 服务性能优化：从各个方向，包括网络优化、操作系统优化、应用优化、客户端优化等，提高服务的性能和响应速度，改善用户体验
* 服务全局流量调度：接入服务的流量，根据容量和服务状态在各个机房间分配流量
* 服务任务调度：服务的各种定时/非定时任务的调度触发及状态监控
* 服务安全保障：包括服务的访问安全、防攻击、权限控制等
* 数据传输技术：包括p2p等各类传输技术的研发应用，也远距离大数据传输等问题的解决
* 服务自动发布部署：部署平台/工具的研发，及平台/工具的使用，做到安全、高效的发布服务
* 服务集群管理：包括服务的服务器管理、大规模集群管理等
* 服务成本优化：尽可能降低服务运行使用的资源，降低服务运行成本
* 数据库管理（DBA）：通过设计、开发和管理高性能数据库集群，使数据库服务更稳定、更高效、更易于管理。
* 平台化的开发：类docker和google borg平台的开发管理，及服务接入技术
* 分布式存储平台的开发优化：类google gfs等分布式存储平台的研发及服务接入

## 2.2 硬件基础

### 2.2.1 CPU架构
* SMP：Symmetric Multi-Processing，对称多处理。共享所有资源（CPU/内存/IO）。
* NUMA：NoN-Uniform Memory Access，非一致存储访问。不共享资源。



### 2.2.2 存储介质

IO总线：南北桥

存储系统的瓶颈一般在IO。

表格 1 存储介质对比

| 类别      | IOPS   | 每GB价格（元） | 容量     | 随机读取 | 随机写入     |
| ----------- | ------ | -------------- | -------- | -------- | ------------ |
| 内存        | 千万级 | 150            | 1G~3     | 友好     | 友好         |
| SSD（闪存） | 35000  | 20             |          | 友好     | 写入放大问题 |
| SAS磁盘     | 180    | 3              |          | 磁盘寻道 | 磁盘寻道     |
| SATA磁盘    | 90     | 0.3            | 0.5T~8TB | 磁盘寻道 | 磁盘寻道     |

备注：早期存储介质的价格差异巨大，所以多级缓存使用了不同介质。随着SSD的降价，多级缓存也可以使用SSD介质。

#### 2.2.2.1 磁盘IO性能评估

​               ![image-20200101103628634](../media/software_enginer/ops_001.png)

图 1一些典型磁盘的性能数据

说明：磁盘由扇区，柱区组成，每扇区大小为512Byte.

磁盘参数组成：平均寻址时间ms，RPM转速，IOPS每秒的IO数，传输率MB/S.

一次IO时间 = 寻址时间(Seek Time) +旋转延时(Rotational Delay) +传送时间(Transfer Time)

这3个参数，分别对应于磁盘的平均寻址时间、盘片旋转速度以及最大传送速度.
* IOPS主要取决于SeekTime, RPM。与IO ChunkSize反比，TransferRate正比。
* MB/s：最大传输速度，在顺序访问时，非常接近IOPS*IO ChunkSize.

于是公式：

IO Time = Seek Time + 60 sec/Rotational Speed/2 + IO ChunkSize/Transfer Rate

IOPS = 1/IO Time



**概念：**

- 随机读写：在随机读写中，每次IO操作的寻址时间和旋转延时不能忽略不计。
- 顺序读写：每次IO操作的寻址时间和旋转延时几乎可忽略。



**磁盘IO性能的四个关键指标：**
* IO Chunk Size：单个IO的大小，数据库存储有个基本的块大小(Block Size)，磁盘页也为一个IO块，缺省为4K。但IO Chunk Size与IO Block Size并没关系。每次IO操作的大小是不固定的，系统会根据需要合并IO次数，集中读写，以提高性能。
* IOPS(IO per Second)：IO系统每秒所执行IO操作的次数。
* 传输速度(Transfer Rate)/ 吞吐率(Throughput)：同传输速度/传输率。磁盘在实际使用的时候从磁盘系统总线上流过的数据量。=IOPS * IO ChunkSize。 随机访问时取决于IOPS，顺序访问时取决于磁盘的最大传输速度。
* IO响应时间(IO Response Time)：IO响应时间也叫IO延时，就是从操作系统内核发出的一个读或者写的IO命令到操作系统内核接收到IO回应的时间。包括了IO在系统中等待时间。



**计算1：计算IOPS**

假设磁盘的转速(Rotational Speed)为15K RPM，平均寻道时间为5ms，最大传输速率为40MB/s, IO chunksize 4K.（这里将读写速度视为一样，实际会差别比较大）。

公式：IO Time = Seek Time + 60 sec/Rotational Speed/2 + IO ChunkSize/Transfer Rate

IOPS = 1/IO Time = 1/(5ms + 60s/15K/2 + 4K/40MB) = 1/(5ms+2ms+0.1ms) = 1/7.1*1000=143

注：**顺序访问**时，寻址时间和旋转延时几乎可忽略，只余下传送时间，这时的IPOS相对于**随机访问**时差别极大。



**计算2：计算磁盘的实际传输速度**

实际上传输速度和IOPS是没有直接关系，在没有缓存的情况下它们共同的决定因素都是对磁盘系统的访问方式以及单个IO的大小。对磁盘进行随机访问时候我们可以利用**IOPS**来衡量一个磁盘系统的性能，此时的传输速度不会太大；但是当对磁盘进行连续访问时，此时的IOPS已经没有了参考的价值，这个时候限制实际传输速度却是**磁盘的最大传输速度**。因此在实际的应用当中，只会用IOPS来衡量小IO的随机读写的性能，而当要衡量大IO连续读写的性能的时候就要采用传输速度而不能是IOPS了。

#### 2.2.2.2 缓存对磁盘IO性能的影响



#### 2.2.2.3 RAID对磁盘IO性能的影响

**RAID提升数据传输率**

当前单个磁盘的平均数据传输速率在20-50MBps之间，并没有完全利用SCSI总线的全部带宽，解决这个问题的方法是采用冗余磁盘阵列技术 （RAID）。N个磁盘组成的数组可以使数据传输速率获得接近N倍的提升，并且可以改善I/O请求的响应时间（同时也增加了IOPS），不同的配置方案对 I/O系统这两方面的影响可参考[Scheuermann, et al.,1998]。显然，这种提高I/O性能的方法是以增加系统硬件成本为代价的。



**示例：计算IOPS**

假设：IPOS为140, 读命中率为90%,写命中率为90%, 读RAID数目为4.

read IOPS = disk_IOPS/(1-read_cache_hit_ratio)*disk_num =140/(1-10%)*4 = 622

write IOPS =disk_IOPS/(1-write_cache_hit_ratio)*disk_num/acture_IO_num =140/(1-10%)*4/1 = 622



## 2.3 系统监控

监控的四个黄金指标：延迟、流量、错误和饱和度。

* 延迟：服务处理某个请求所需要的失败。如要求API响应时间在500ms内。

* 流量：针对系统负载需求所进行的度量。如每秒HTTP请求数、QPS

* 错误：请求失败的速率。

* 饱和度：指系统中最为受限的资源具体指标的度量，通常指系统资源中最薄弱的一环如CPU/内存/IO等等。



## 2.4 性能 Performance

主要监控项：CPU使用率，磁盘IO，系统负载，程序服务状态和响应时间监控。

**经验值**：CPU不要高于70%，系统负载不要高于CPU个数*2。

### 2.4.1 性能指标

网站的性能由这些内容组成：带宽占用率，CPU利用率，内存使用率，响应时间，请求并发数（Ququests Per Second)。

**服务器并发处理能力**

- 呑吐率
- CPU并发计算
- 系统调用： 尽量少调用，减少内核CPU
- 内存分配
- 持久连接
- Io模型：阻塞/非阻塞，select/poll/epoll/kqueue/AIO
- 服务器并发策略：多线程，多进程，同步异步等。



#### 2.4.1.1 高并发指标

高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。

高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。


* 响应时间：对请求作出响应所需要的时间。通常取平均响应时间。
* 吞吐量：Throughput，单位时间内处理的请求数量。
* QPS或TPS：Query/事务 Per Second，每秒查询量。一般单机几百~几千QPS。在互联网领域，这个指标和吞吐量区分的没有这么明显。
* 并发数：系统同时处理的请求数或者用户数。同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。



**计算公式：**
* QPS = 并发数/平均响应时间
* 并发数 = QPS * 平均响应时间
* 响应时间 = 网络传输时间 + 应用服务器处理时间 + 数据库服务器处理时间



一个系统的吞吐量（承压能力）与请求request对CPU的消耗、外部接口、IO等紧密关联。单个请求消耗的系统资源越少，系统吞吐能力就越高，反之越低。

吞吐量从不同角度可以表现为不同的形式：
* 从业务角度来看：请求数/秒、页面数/秒等（体现应用服务器和代码的瓶颈）
* 从网络角度来看：字节/秒 （体现网络/服务器等的瓶颈）



**知名服务的系统吞吐量**

表格 2 知名服务系统吞吐量列表

| 知名服务 | 数据时间 | QPS         | 平均响应时间 | 数据量                                            | 其它                                       |
| -------- | -------- | ----------- | ------------ | ------------------------------------------------- | ------------------------------------------ |
| 百度贴吧 | 2011     | 10万        |              | 百亿帖子，某些热门话题千万回复，P级视频存储       |                                            |
| 腾讯微信 | 2011     |             |              | 10个月5千万用户，千万级在线                       | 2010.1.26发布1.0版本，2010.10发布3.0版本。 |
| QQGame   |          |             |              | 3.2亿注册用户，2千万活跃用户数，400万人同时在线。 |                                            |
| 淘宝搜索 |          |             |              |                                                   |                                            |
| 一淘     |          |             |              |                                                   |                                            |
| 新浪微博 |          |             |              |                                                   |                                            |
| 豆瓣     | 2009     | 峰值500~600 |              | 280万注册用户，约1/4活跃用户，千万级非注册用户。  | 每天约2千万请求。                          |

备注：



#### 2.4.1.2 设备传输率

* 磁盘IO：IOPS 120次左右，平均寻址时间在5ms左右。最大传输率通常20MB/s，IO ChunkSize 10K，实际传输率=IOPS*IO ChunkSize=10MB/s
* 网络带宽：网络带宽10MB/s（Mbit/s），全速传输一天可传输 3600*24*10MB=864GB。
* 以太网带宽：取决于网卡，常见是150MB/S~300MB/S，也就是局域网内部传输率一天可达到3600*24*150MB=12960GB=13TB

备注：带宽速度常是性能瓶颈。



### 2.4.2 在线服务故障排查

说明：类unix系统下命令和命令参数通常大小写敏感。

1） CPU过高

示例：以tomcat实例为例，定位哪个服务进程、哪个线程、哪段代码导致CPU过载？

步骤一：找最耗CPU的进程

$ top c，显示进程运行信息列表

$ 键入P，进程按照CPU使用率排序



步骤二：找最耗CPU的线程

$ top -Hp [pid] 显示一个进程的线程运行信息列表

$ 键入P，线程按照CPU使用率排序



步骤三：将线程TID转化为16进制

$ printf "%x\n" [TID]



步骤四：查看堆栈

工具：pstack/jstack/grep

$ jstack [pid] | grep [TID] -C5 --color



步骤五：查看系统调用

工具：stract

$ stract [pid]



### 2.4.3 本节参考

[1]. [IO系统性能之一：衡量性能的几个指标](http://num7.javaeye.com/blog/787209)

[2]. [IO系统性能之二：缓存和RAID如何提高磁盘IO性能](http://num7.javaeye.com/blog/787211) http://num7.javaeye.com/blog/787211

[3]. [IO系统性能之三：在Linux中监视IO性能](http://num7.javaeye.com/blog/787217)



## 2.5 高可用性HA

参见  《[网站优化工具.md](../软件可复用/tools.工具/网站优化工具.md)》keepalived章节



**可用性定义**

* 基于时间：可用性=系统正常运行时间/（系统正常运行时间+停机时间） >=99.99%
* 合计（请求成功率）：可用性=成功请求数/总的请求数 >=99.99%

 **HA的几个常用指标**

* 平均故障间隔时间MTBF：Mean Time Between Failure
* 平均修复时间 MTTR: Mean Time To Repair
* 可有性 Avaliability：常用N个9来进行量化



### SLA协议

- SL1: Service-Level Indicator，服务质量指标。某项服务质量的一个具体量化指标。
- SLO: Service-Level Objecct，服务质量目标。服务的某个SL1的目标范围。
- SLA：Service-Level Agreement的[缩写](https://baike.baidu.com/item/缩写/1948062)，意思是[服务等级协议](https://baike.baidu.com/item/服务等级协议/20861172)。是关于[网络服务](https://baike.baidu.com/item/网络服务/9498645)供应商和客户间的一份合同，其中定义了[服务类型](https://baike.baidu.com/item/服务类型/5935663)、服务质量和客户付款等术语。

说明：SLO和SLA的一个简单区别在于如果SLO没有达到时，会有什么后果。



**典型的SLA包括以下项目：**
* 分配给客户的最小带宽；
* 客户带宽极限；
* 能同时服务的客户数目；
* 在可能影响用户行为的网络变化之前的通知安排；
* 拨入访问可用性；
* 运用统计学；
* 服务供应商支持的最小网络利用性能，如99.9%[有效工作时间](https://baike.baidu.com/item/有效工作时间)或每天最多为1分钟的停机时间；
* 各类客户的流量优先权；
* 客户技术支持和服务；
* 惩罚规定，为服务供应商不能满足 SLA 需求所指定。




## 2.6 CICD持续集成-持续部署

CI：Continuous Integration. CI是敏捷开发的最有用的实践。

TFS和Jenkins是流行的CI工具。

表格 3 每日构建与发布流程列表

| 测试项       | 详细项                                                       | 备注 |
| ------------ | ------------------------------------------------------------ | ---- |
| 源码静态扫描 | 检查源码规范、注释覆盖率、代码圈复杂度。还可检查代码安全性。 |      |
| 环境配置     | 检测配置文件名  检测线上和测试环境配置差异                   |      |
| 单元测试脚本 | 脚本运行正确率、覆盖率                                       |      |
| 自动化布署   | 代码脚本上传  检测系统、开发工具需求（尝试docker）           |      |



## 2.7 服务集群管理

详见 《[大数据集群管理.md](../大数据和AI/bigdata/大数据集群管理.md)》



## 2.8 网站整体优化

详见 《网站架构设计与开发.md》、《网站优化工具.md》



## 本章参考

[1]. selenium + python自动化测试环境搭建 http://www.cnblogs.com/fnng/archive/2013/05/29/3106515.html

[2]. 性能测试工具列表：http://www.opensourcetesting.org/performance.php

[3]. Keepalive 之高可用实现 https://www.jianshu.com/p/a209cb8ed693



# 3  运维工具篇

## 3.1 运维工具列表

运维工程师使用的[运维平台](https://baike.baidu.com/item/运维平台)包括：
* Web服务器：apache、tomcat、nginx、lighttpd
* 数据库：mysql、oracle、sqlserver
* 分布式平台：hdfs、mapreduce、spark、storm、hive
* 分布式数据库：hbase、cassandra、redis、MongoDB



### 3.1.1 运维项

表格 4运维项及运维工具列表

| 运维项         | 简介                                                         | 使用的工具                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 日常任务       | 数据库定期备份、数据分发和同步                               | 参考以下：定时操作timer、数据分发和同步、自动化测试、服务器/系统的性能监控。 |
| 自动化布署     | 使用各种脚本实现布署的自动化。  包括数据的分发同步、配置文件的变更。 | ansible、sshpt、salt                                         |
| 容器           |                                                              | lxc、docker、K8s                                             |
| 虚拟化         |                                                              | openstack、xen、kvm LXC                                      |
| 配置管理       |                                                              | puppet、cfengine Consul  Zookeeper                           |
| 负载均衡       |                                                              | LVS、Haproxy、Nginx                                          |
| 传输工具       |                                                              | scribe、flume、fabric、                                      |
| 监控           |                                                              | nagios、ganglia、cacti、zabbix,   snmp                       |
| 安全           |                                                              | kerberos、selinux、acl、iptables                             |
| 问题追查       |                                                              | netstat、top、tcpdump、last                                  |
| 日志统计和分析 |                                                              | 百度站长流量跟踪系统、站长工具                               |
| 代码质量分析   | 从编码规范、代码质量属性多角度分析技术债务                   | sonar                                                        |
| 网络工具       |                                                              | curl tcpcopy                                                 |
| 编辑           | 编辑markdown格式文件                                         | mkdocs typora pandoc                                         |

备注：1. OS内主备机之间要设置NTP（网络时间）同步，最好在同一时区。
2. ssh 无终端后台挂起，ssh连接断了不会导致进程中断。
```sh
$ daemon [process]
$ nohup ./xxx &
=./xxx &; exit;
=screen ./xxx
```


### 3.1.2 轻量级运维工具

表格 5 轻量级运维（系统工具）列表

| 运维项         | 简介                                                      | 使用的工具                                   |
| -------------- | --------------------------------------------------------- | -------------------------------------------- |
| 系统性能监控   | 监控CPU使用率，磁盘IO， 系统负载， 程序服务状态和响应时间 | top、free、netstat、ps、pgrep                |
| 定时操作timer  | 定时执行任务。                                            | windows: 计划任务  linux：crontab            |
| 数据分发和同步 |                                                           | rsync, ssh, scp, wget                        |
| 共享文件系统   |                                                           | nfs, smbfs, usefs, nfts,   proc....use mount |



### 3.1.3 命令行运维工具

#### 3.1.3.1 系统运维项及工具列表

表格 6 系统运维项

|          | 工具            | 详介                                                         | 实现原理                                                     |
| -------- | --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| cpu | top/vmstat/sar/ | cpu = user + nice + system + idle                            | /proc/stat=100*(user+nice+system)/(user+nice+system+idle)  /proc/cpuinfo |
| 内存     | top/free/vmstat | 应用程序可使用内存 = 物理内存Mem_free + buffers + cached.  大小比较：VIRT > RES > SHR | /proc/meminfo                                                |
| 负载     | top/uptime      |                                                              | /proc/loadavg                                                |
| IO       | iostat          |                                                              |                                                              |
| 网络     | netstat/ping/   | 查看端口及服务                                               | /etc/services                                                |
|          | tracert         | 路由跟踪                                                     |                                                              |
|          | telent          | telnet ip port                                               | telnet协议                                                   |
|          | lsof            | lsof -i                                                      |                                                              |
|          | curl            | curl -–head [net-site]                                       |                                                              |
| 磁盘     | df/du           |                                                              |                                                              |
| 进程     | ps              |                                                              | /proc/[pid]                                                  |
| 线程     | ps              | ps –LF [pid] #进程所属线程  <br>ps -o nlwp [pid]             | 查看进程内的线程，线程数                                     |
|          | pstree          | pstree  -p                                                   |                                                              |
| dns      | dig/nslookup    |                                                              | apt-get install dnsutils                                     |
| 系统调用 | strace/dmesg    | strace -p  [pid]                                             |                                                              |
|                                                    ||||



表格 7 linux/windows下一些常用命令比较

| 命令               | linux                     | windows                     |
| ------------------ | ------------------------- | --------------------------- |
| 查看监听端口如5000 | netstat -anpl \|grep 5000 | netstat -ano\|findstr  5000 |
| 查看进程           | ps -ef                    | tasklist                    |
| 杀死进程pid        | kill -9 [pid]             | taskkill /f -pid [pid]      |



**1)查看cpu**

说明： time xxx 得到的时间是： real = user + system

cpu.sh

```sh
# cmd：sar-System Activity Reporter, mpstat, top, vmstat
# imp：/proc/stat = 100 *(user + nice + system)/(user + nice + system + idle)
idle=`/usr/bin/mpstat 1 1 | /bin/grep Average | awk '{print $9}'`
used=`echo "100 - $idle" | /usr/bin/bc -l -s`
```


**2)查看内存**

说明：内存以KB为单位。
* VIRT：virtual memory usage 虚拟内存大小，包括进程使用的库、代码、数据等
* RES：resident memory usage 常驻内存 ，进程当前使用的内存大小（不包括SWAP）和进程间共享内存。
* SHR：shared memory 共享内存。包括进程间共享内存、库内存。
* 计算某个进程所占的物理内存大小公式：RES – SHR

备注：1. 假如进程申请100m的内存，但实际只使用了10m，那么VIRT会增长100m，而RES增长10m。
2. 一般 VIRT > RES > SHR
mem.sh
```sh
# cmd：free, vmstat, top
# imp：/proc/meminfo  = 100  *  (cmem  /  umem)
#    /proc/vmstat

/usr/bin/free |grep Mem|awk '{print $4/$2*100}'
/usr/bin/free |grep Swap|awk '{print $4/$2*100}'

# application momory utilization ratio
/usr/bin/free |grep Mem|awk '{print ($3-$7_$8)/$2*100}'
```

**示例：free**

```sh
qfwu@test30：~$ free
       total    used    free   shared  buffers   cached
Mem：   1026224  1001912   24312     0   109464   767516
-/+ buffers/cache：  124932   901292
Swap：  1052248    144  1052104
```

说明：
* 第一行为列属性名，shared为共享所用的内存，buffers为系统块设备文件缓存， cached为文件缓存。其中buffers+cached是为了提高文件读取的性能，当应用程序需要内存时，buffers+cached将快速回收。
* 第二行Mem指以操作系统角度来看，总共有1026224内存，其中used为1001912，total=used+free， used=buffers+cached+内核使用的内存+应用程序使用的内存；
* （可选）第三行-/+ buffers/cache指以应用程序角度来看，第一行的total_1026224 = used + free; free _901292 = 第一行的buffers_109464 + cached_767516 + free_24312.
* 第四行swap指交互分区。当可用内存少于限定值时，就会开始进行交换，原理是用空间换时间，增大内存使用大小。

简而言之，应用程序可使用内存=物理内存Mem_free + buffers + cached.



**3)查看负载load**

load averages，系统负载平均值，计算当前正在运行线程（运行+等待)的平均数据，一般会显示1、5、15分钟的平均值。
load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU的数量，结果高于5的时候就表明系统在超负荷运转了。
load.sh
```sh
# cmd：uptime, top
# imp：/proc/loadavg
uptime |awk -Faverage '{print $2}'|awk '{print $2}'|awk -F, '{print $1}'
```

**4)查看网络连接**
```sh
# tcpstate.sh
# cmd：netstat 统计tcp套接字状态
netstat | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'

# 显示监听状态的端口和程序  -l监听服务 -p显示程序名 -n服务名解析成端口(可以在/etc/services找到对应映射)
netstat -npl
```



**5)查看设备IO（详见iostat解读）**

```sh
# io.sh
# cmd：iostat
iostat -x /dev/sda|grep sda |awk '{print $8}'
```


6) 查看其它
* 磁盘使用情况：df –h
* 进程信息：cat /proc/[pid]
* 进程里的线程数：ps –LF [pid] 或者 pstree -p



#### 3.1.3.2 top~监控系统资源综合情况

cpu：idle项说明是空闲比率，其余是被使用的。（多核时，某进程CPU可能会大于100%。按数字1可显示各CPU使用情况）

**top排序**
* shift + P CPU
* shift + M memory
* 敲击键盘b（打开/关闭加亮效果）：横向
* 敲击键盘x（打开/关闭加亮效果）：纵向

 ![image-20200101103859218](../media/software_enginer/ops_top_001.png)

 **第一行：**
 13:42:59 当前系统时间
 6 days, 9:29 系统已经运行了6天6小时29分钟（在这期间没有重启过）
 3 users 当前有3个用户登录系统
 load average: 3.06,3.01, 1.79 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
 load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU（即实际CPU核数）的数量，结果高于5的时候就表明系统在超负荷运转了。

 **第二行： Tasks 任务（进程）**
 系统现在共有131个进程，其中处于运行中的有3个，127个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有1个。

 **第三行：cpu状态**
 10.6% us 用户空间占用CPU的百分比。
 2.2% sy 内核空间占用CPU的百分比。
 0.0% ni 改变过优先级的进程占用CPU的百分比
 84.5% **id 空闲CPU百分比**（如果这项比例低于50%，才需要看其它项）
 2.5% wa IO等待占用CPU的百分比
 0.1% hi 硬中断（Hardware IRQ）占用CPU的百分比
 0.0% si 软中断（Software Interrupts）占用CPU的百分比

**第四行：内存状态**
 8300124k total 物理内存总量（8GB）
 5979476k used 使用中的内存总量（5.7GB）
 2320648k free 空闲内存总量（2.2G）
 455544k buffers 缓存的内存量 （434M）

**第五行：swap交换分区**
 8193108k total 交换区总量（8GB）
 41568k used 使用的交换区总量（40.6M）
 8151540k free 空闲交换区总量（8GB）
 4217456k cached 缓冲的交换区总量（4GB）

服务器的可用内存： free + buffers + cached



#### 3.1.3.3 iostat~监控IO性能

**iostat参数说明**

```shell
rrqm/s 每秒进行merge的读操作数目。rqm—request merge
wrqm/s每秒进行merge的写操作数目。
r/s 每秒完成的读I/O设备次数。
w/s 每秒完成的写I/O设备次数。
rsec/s 每秒读扇区数。sec--sector
wsec/s 每秒写扇区数。
rkB/s每秒读K字节数。
wkB/s 每秒写K字节数。
avgrq-sz 平均每次设备I/O操作的数据大小(扇区)。 rq--request
avgqu-sz 平均I/O队列长度。qu--queue
await 平均每次设备I/O操作的等待时间(毫秒)。
svctm平均每次设备I/O操作的服务时间(毫秒)。
%util 一秒中有百分之多少的时间用于I/O操作，或者说一秒中有多少时间I/O队列是非空的。
```



**公式：（根据iostat大致估算）**

平均单次IO大小(IO Chunk Size) <=> avgrq-sz（扇区数）
 平均IO响应时间(IO Response Time) <=> await
 IOPS(IO per Second) <=> r/s + w/s
 吞吐率(Throughtput) <=> rkB/s + wkB/s



 ![image-20200101103925606](../media/software_enginer/ops_003.png)

图 2 IO的执行过程的各个参数

上表说明：在从OS Buffer Cache传入到OS Kernel(Linux IO scheduler)的读IO操作的个数实际上是rrqm/s+r/s，直到读IO请求到达OS Kernel层之后，有每秒钟有rrqm/s个读IO操作被合并，最终转送给磁盘控制器的每秒钟读IO的个数为r/w；在进入到操作系统的设备层 (/dev/sda)之后，计数器开始对IO操作进行计时，最终的计算结果表现是await，这个值就是我们要的IO响应时间了；svctm是在IO操作 进入到磁盘控制器之后直到磁盘控制器返回结果所花费的时间，这是一个实际IO操作所花的时间，当await与svctm相差很大的时候，我们就要注意磁盘的IO性能了；而avgrq-sz是从OS Kernel往下传递请求时单个IO的大小，avgqu-sz则是在OS Kernel中IO请求队列的平均大小。



**示例1：测试本地磁盘IO性能**
```sh
jb-wuqf@is13084905-0123：~/test/replace_novel$ /usr/bin/time dd if=/dev/zero of=/tmp/foo bs=4k count=1024 > ~/disk.log

0.00user 0.02system 0：00.02elapsed 91%CPU (0avgtext+0avgdata 0maxresident)k

0inputs+0outputs (0major+209minor)pagefaults 0swaps
```


**示例2：iostat -x**
```sh
jb-wuqf@is13084905-0442：~$ iostat -x
Linux 2.6.9-42.ELsmp (is13084905-0442) 2011
avg-cpu：%user  %nice  %sys %iowait  %idle
      5.97  0.00  0.31  8.30  85.43
Device： rrqm/s wrqm/s  r/s  w/s rsec/s wsec/s  rkB/s  wkB/s avgrq-sz avgqu-sz  await svctm %util
sda     26.81  8.92 76.85 5.68 184.06 116.80   92.03  58.40   3.65   0.05  0.55  0.93  7.72
sdb     0.01  3.27 0.13 1.64  4.30  39.28   2.15  19.64  24.63   0.00  1.39  0.82  0.14
```


### 3.1.4 编程语言相关的运维工具

表格 8 编程语言相关的运维工具列表

| 编程语言 | 命令             | 简介                | 详述 |
| -------- | ---------------- | ------------------- | ---- |
| Java     | jps              | JVM进程状态查看工具 |      |
|          | jstat/jinfo/jmap |                     |      |
| Python   |                  |                     |      |

备注：



## 3.2  虚拟化工具与镜像

表格 9 常用虚拟化工具镜像源

| 工具           | 简介                            | 配置信息                                                  | 官网镜像                        | 中国区镜像                     |
| -------------- | ------------------------------- | --------------------------------------------------------- | ------------------------------- | ------------------------------ |
| docker         | images。各种容器镜像。          | 镜像制作文件: Dockerfile;  <br>服务端配置文件:daemon.json | https://hub.docker.com          | https://registry.docker-cn.com |
| docker-compose | 容器编排，管理多个容器。        | docker-compose.yml                                        |                                 |                                |
| vagrant        | 管理虚拟环境。虚拟OS名称为box。 | box配置文件：vargrantfile  配置路径：~/.vagrant.d/        | https://app.vagrantup.com/boxes |                                |

备注： 其它常用仓库镜像 参见 《项目开发环境工具》软件制品仓库Aritfactory章节。



### 3.2.1 VirtualBox (vbox)

VirtualBox 是 Oracle 开源的虚拟化系统，和 VMware 是同类产品，支持多个平台，可以到官方网站：https://www.virtualbox.org/wiki/Downloads 下载适合你平台的 VirtualBox 最新版本并安装。



### 3.2.2 Vagrant

Vagrant 是Hashicorp公司基于Ruby开发的用于创建和部署虚拟机开发环境，通常作为虚拟机管理软件。Vagrant 基于 VirtualBox 等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用 Vagrant 可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，这样我们平时还可以在开发机模拟分布式系统。

vagrant下载相应系统平台的安装包：http://www.vagrantup.com/downloads.html



表格 vagrant boxes列表

| boxes                                    | 下载地址（优先级：中国区 >  官网）                           | 注意事项                    |
| ---------------------------------------- | ------------------------------------------------------------ | --------------------------- |
| bionic-server-cloudimg-amd64-vagrant.box | https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/bionic-server-cloudimg-amd64-vagrant.box | ubuntu-18.04 root初始无密码 |
| ubuntu/trusty64                          | https://app.vagrantup.com/ubuntu/boxes/trusty64              |                             |
| centos/7                                 | https://app.vagrantup.com/centos/boxes/7                     |                             |

备注：1. box本地存放路径~ ~/.vargrant.d/boxes/。 vagrant ssh登陆到box。

2. root密码： 在Ubuntu 18.04 Linux上没有默认的root密码。但是，如果您需要以root特权执行命令，则可以在命令前添加前缀`sudo`。更改默认的空白root密码和[设置root密码](https://ubuntuqa.com/how-to-set-a-root-password-on-ubuntu-18-04-bionic-beaver-linux)输入：sudo passwd。



#### **Vagrant命令**

```sh
Usage: vagrant [options] <command> [<args>]
  -v, --version          Print the version and exit.
  -h, --help            Print this help.

Common commands:
   box       manages boxes: installation, removal, etc.
   cloud      manages everything related to Vagrant Cloud
   destroy     stops and deletes all traces of the vagrant machine
   global-status  outputs status Vagrant environments for this user
   halt      stops the vagrant machine
   help      shows the help for a subcommand
   init      initializes a new Vagrant environment by creating a Vagrantfile
   login
   package     packages a running vagrant environment into a box
   plugin     manages plugins: install, uninstall, update, etc.
   port      displays information about guest port mappings
   powershell   connects to machine via powershell remoting
   provision    provisions the vagrant machine
   push      deploys code in this environment to a configured destination
   rdp       connects to machine via RDP
   reload     restarts vagrant machine, loads new Vagrantfile configuration
   resume     resume a suspended vagrant machine
   snapshot    manages snapshots: saving, restoring, etc.
   ssh       connects to machine via SSH
   ssh-config   outputs OpenSSH valid configuration to connect to the machine
   status     outputs status of the vagrant machine
   suspend     suspends the machine
   up       starts and provisions the vagrant environment
   upload     upload to machine via communicator
   validate    validates the Vagrantfile
   version     prints current and latest Vagrant version
   winrm      executes commands on a machine via WinRM
   winrm-config  outputs WinRM configuration to connect to the machine

For help on any individual command run `vagrant COMMAND -h`
Additional subcommands are available, but are either more advanced
or not commonly used. To see all subcommands, run the command
`vagrant list-commands`.
```



**vagrant常用命令**

**法1**： 本地下载boxes，然后初始化， 会产生 Vagrantfile文件。示例box名称是ubuntu/bionic

```sh
# vagrant box add <远程或本地box文件名称> <box文件>
# 1）添加远程box文件，示例生成box名称是ubuntu/bionic
vagrant box add \
https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/bionic/current/bionic-server-cloudimg-amd64-vagrant.box \
--name ubuntu/bionic

# 2) 添加本地box文件, 示例生成box名称是centOS-7
vagrant box add centos7 centOS-7.box

# 查看 box是否添加成功
vagrant box list

# 初始化上面添加的 box，初始化后会在当前目录生成文件Vagrantfile
vagrant init <本地 box 名称>
```



**法２**：直接 Vagrantfile文件，不需init

```shell
Vagrant.configure("2") do |config|
  config.vm.box = "ubuntu/trusty64"
end
```



启动并连接虚拟机

```sh
# 启动虚拟机（先在本地找，本地没有到仓库下载）。启动后自动将当前目录和虚拟机的/vargrant目录共享
vagrant up
# 连接虚拟机
vagrant ssh
# 查看vagrant共享目录
df -h
```



#### **vagrant配置文件：VagrantFile**

Vagrantfile 主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant 的一些基础配置。Vagrant 是使用 Ruby 开发。

修改完配置后需要执行 vagrant reload 重启 VM 使其配置生效。

**vagrant启动一个虚拟机**

```sh
Vagrant.configure("2") do |config|
     # box配置，定义了虚拟机使用的操作系统类型及版本
     config.vm.box = "centos/7"
     # VM配置
     config.vm.provider "virtualbox" do |v|
        v.customize ["modifyvm", :id, "--name", "ubuntu", "--memory", "1024"]
     end
     config.vm.hostname = "kubernetes"
end
```

**vagrant启动虚拟机集群**

下列是2个VM，分别是web和db，在同一网段，使用同一个box启动
```sh
Vagrant.configure("2") do |config|
 config.vm.define :web do |web|
  web.vm.provider "virtualbox" do |v|
     v.customize ["modifyvm", :id, "--name", "web", "--memory", "512"]
  end
  web.vm.box = "ubuntu-server-16.04"
  web.vm.hostname = "web"
  web.vm.network :private_network, ip: "11.11.1.1"
 end

 config.vm.define :db do |db|
  db.vm.provider "virtualbox" do |v|
     v.customize ["modifyvm", :id, "--name", "db", "--memory", "512"]
  end
  db.vm.box = "ubuntu-server-16.04"
  db.vm.hostname = "db"
  db.vm.network :private_network, ip: "11.11.1.2"
 end
end
```



### 3.2.3 Hyper-V

Hyper-V是微软的一款虚拟化产品，是微软第一个采用类似Vmware ESXi和Citrix Xen的基于hypervisor的技术。

Hyper-V是微软提出的一种系统管理程序虚拟化技术，能够实现桌面虚拟化。最早版本在Windows Server 2008出现。

Windows 上的 Hyper-V 支持虚拟机中的许多不同操作系统，其中包括各种版本的 Linux、FreeBSD 和 Windows。

windows下启用Hyper-V，要求下面四项都是YES.

```shell
$ systeminfo
Hyper-V Requirements:      VM Monitor Mode Extensions: Yes
                           Virtualization Enabled In Firmware: Yes
                           Second Level Address Translation: Yes
                           Data Execution Prevention Available: Yes
```



### 3.2.4 容器 Docker

详见 《[docker用户手册.md](../软件可复用/tools.工具/docker用户手册)》



## 3.3 容器编排

编排Orchestration这一术语来源于音乐领域，根据作曲家的作品，编曲决定音乐作品的某一部分由某种乐器以某种方式在某个时机来演奏，这一过程称为编排。

编排这一术语被借用到了IT领域，

*  Service Orchestration： 在SOA和微服务体系中，针对Service。

*  Cloud Orchestration：在Cloud 体系中，针对云资源描述。

*  容器编排：负责容器的启停调度，并且通过管理容器集群来提升容器使用率。



表格6  容器编排K8s/Mesos/Swarm比较

|           | K8s                                                          | Mesos                                                        | Swarm                                                        |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| <br/>简介 | 基于Google在过去十五年来大量生产环境中运行工作负载的经验。  高度通用，开源。 | 分布式调度系统内核。作为资源管理器的Apache Mesos在容器之前就已经出现很久了，支持运行容器化化和非容器化的工作负载。  适用于大型系统 | Docker开发的调度框架。  标准Docker API的使用。  易于集成和设置，灵活的API，有限的定制。 |
| 支撑厂商  | Google                                                       | Mesosphere                                                   | Docker                                                       |
| 核心概念  | APIServer Pod Label  Service  kubelet                        | Master Slave   Zookeeper Framework                           |                                                              |
| 特性      | 通过Pods这一抽象的概念，解决Container之间的依赖与通信问题。Pods,  Services, Deployments是独立部署的部分，可以通过Selector提供更多的灵活性。内置服务注册表和负载平衡。 | 可以支持应用程序的健康检查，开放的架构。支持多个框架和多个调度器，通过不同的Framework可以运行Haddop/Spark/MPI等多种不同的任务。 | 由于随Docker引擎一起发布，无需额外安装，配置简单。支持服务注册、服务发现，内置Overlay Network以及Load Balancer。与Docker CLI非常类似的操作命令，对熟悉Docker的人非常容易上手学习。 |

备注：2016年容器三家平分秋色；到2017年，K8s成为主流。



### K8s

详见 《[kubernetes用户手册.md](../tools.工具/kubernetes用户手册.md)》



### Mesos

参见 《[大数据集群管理.md](./大数据集群管理.md)》 Mesos章节



### Docker Swarm

Docker Swarm是一个由Docker开发的调度框架。由Docker自身开发的好处之一就是标准Docker API的使用，Swarm由多个代理（Agent）组成，把这些代理称之为节点（Node）。这些节点就是主机，这些主机在启动Docker Daemon的时候就会打开相应的端口，以此支持Docker远程API。这些机器会根据Swarm调度器分配给它们的任务，拉取和运行不同的镜像。

![img-DockerSwarm结构](../media/sf_reuse/arch/arch_cncf_004.png)

图 Docker Swarm结构

Swarm基本概念：

*  Manager：在整个集群中分配任务，集群中控制Worker的节点。
*  Worker：运行由Manager节点分配的任务.
*  Services：跨节点的执行特定接口的一组容器。.
*  Key-valuestore：内建的Key-Value存储解决方案，做服务发现、服务注册以及主节点选举工作。



## 3.4  持续集成CI工具：Jenkins

详见 《[jenkins用户手册.md](../软件可复用/tools.工具/jenkins用户手册.md)》

Jenkins是一个开源软件项目，是基于Java开发的一种[持续集成](https://baike.baidu.com/item/持续集成)工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。可以用于自动化执行所有与编译、测试、提交、调度软件相关的任务。



Jenkins功能包括：
* 可以签出源码，执行测试（测试覆盖率），统计TODO任务，发送结果通知和编写文档等。
* 持续的软件版本发布/测试项目。
* 监控外部调用执行的工作。



## 3.5  Devops工具

详见 《[Devops指南.md](./Devops指南.md)》 TFS



## 3.6  自动化运维工具

表格 13 自动化运维工具比较列表

|           | 环境   | 简介                                                        | 优点                                                         | 缺点                                                         |
| --------- | ------ | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Ansible   | python | python开发的自动化运维工具，通过SSH方式执行命令（命令式）。 | 部署成本低；不需要Agent；学习成本低；完备模块。              | WINDOWS环境兼容差；需要python环境。                          |
| Saltstack | python | python开发的集中化运维工具。功能相当于Ansible+Puppet。      | 可以Ansible样的主动触发命令；也可Puppeet样的SLS文件描述状态。 | 集中化操作的返回结果不够友好，可能无结果返回。无源情况下安装较为不便。 |
| Fabric    | python | python工具，简化SSH+SHELL。                                 |                                                              |                                                              |
| Puppet    | Ruby   | Ruby开发的集中化运维工具。（声明式）                        | 丰富模块；多操作系统兼容。基于证书的通讯。                   | 需要Ruby环境；  命令式触发功能较弱。                         |



### Ansible

环境搭建与部署的自动化。

运行环境：python

依赖模块(python)：paramiko PyYAML Jinja2 httplib2 six

配置文件：/etc/ansible/[ansible.cfg](https://raw.github.com/ansible/ansible/devel/examples/ansible.cfg)



测试命令

`$ ansible all -m ping --ask-pass`



### Puppet

**概述**

puppet是一个IT基础设施自动化管理工具，它能够帮助系统管理员管理基础设施的整个生命周期： 供应(provisioning)、配置(configuration)、联动(orchestration)及报告(reporting)。

基于puppet ，可实现自动化重复任务、快速部署关键性应用以及在本地或云端完成主动管理变更和快速扩展架构规模等。

基于ruby语言开发。2.0.0之前遵循GPL 协议, 2.7.0 以后使用(Apache 2.0 license)

对于系统管理员是抽象的，只依赖于ruby与facter。

能管理多达40 多种资源，例如：file、user、group、host、package、service、cron、exec、yum repo等。



**名词术语**
* 资源：是puppet的核心，通过资源申报，定义在资源清单中。相当于ansible中的模块，只是抽象的更加彻底。
* 类：一组资源清单。
* 模块：包含多个类。相当于ansible中的角色。
* 站点清单：以主机为核心，应用哪些模块。



**工作流程**

puppet与其他手工操作工具有一个最大的区别就是 puppet的配置具有稳定性,因此你可以多次执行puppet, 一旦你更新了你的配置文件,puppet就会根据配置文件来更改你的机器配置,通常每30分钟检查一次。.

 ![image-20200101103954438](../media/software_enginer/ops_004.png)

图 4 puppet的工作流程



**使用模型**

puppet的使用模型分为单机使用模型和master/agent模型，下面我们来看看这两个模型的原理图。

1). 单机使用模型

实现定义多个manifests --> complier --> catalog --> apply



2). master/agent模型

master/agent模型实现的是集中式管理，即 agent 端周期性向 master 端发起请求，请求自己需要的数据。然后在自己的机器上运行，并将结果返回给 master 端。

 ![image-20200101104007080](../media/software_enginer/ops_005.png)

图 5 puppet的master/agent模式架构



 ![image-20200101104035765](../media/software_enginer/ops_006.png)

图 6 puppet的master-agent模式的工作原理



### Saltstack

SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，基于Python语言实现，结合轻量级消息队列（ZeroMQ）与Python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。

通过部署SaltStack，我们可以在成千万台服务器上做到批量执行命令，根据不同业务进行配置集中化管理、分发文件、采集服务器数据、操作系统基础及软件包管理等，SaltStack是运维人员提高工作效率、规范业务配置与操作的利器。



**SaltStack工作原理**

SaltStack 采用 C/S模式，server端就是salt的master，client端就是minion，minion与master之间通过ZeroMQ消息队列通信

minion上线后先与master端联系，把自己的pub key发过去，这时master端通过salt-key -L命令就会看到minion的key，接受该minion-key后，也就是master与minion已经互信

master可以发送任何指令让minion执行了，salt有很多可执行模块，比如说cmd模块，在安装minion的时候已经自带了，它们通常位于你的python库中，locate salt | grep /usr/ 可以看到salt自带的所有东西。



### Fabric

python工具，简化SSH+SHELL。

Fabric 是一个 Python 的库和命令行工具，用来提高基于 SSH 的应用部署和系统管理效率。
更具体地说，Fabric 是：

*  一个让你通过 命令行 执行 无参数 Python 函数 的工具；
*  一个让通过 SSH 执行 Shell 命令更加 容易 、 更符合 Python 风格 的命令库（建立于一个更低层次的库）。

```python
# fabfile.py
def hello(name="world"):
    print("Hello %s!" % name)
```

```sh
# 执行命令
$ fab hello:name=Jeff
Hello Jeff!
```


fabric常用的几个API

*  local  本地执行
*  open_shell
*  run    远程主机执行SHELL命令
*  sudo   在远程主机上使用超级用户权限执行 shell 命令
*  prompt
*  put  移动文件
*  rebot
*  require
*  env.hosts = ['my_server']


示例：

```PYTHON
from fabric.api import local
env.hosts = ['my_server'] # 设置全局主机列表
def prepare_deploy():
   local("./manage.py test my_app")
   local("git add -p && git commit")
   local("git push")

def deploy():
    code_dir = '/srv/django/myproject'
    with cd(code_dir):
        run("git pull")
        run("touch app.wsgi")
```



## 3.7 进程管理 Supervisor

supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具。可以很方便的监听、启动、停止、重启一个或多个进程。用supervisor管理的进程，当一个进程意外被杀死，supervisor监听到进程死后，会自动将它重启，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。

\# 安装，安装好后在/etc/会生成一个supervisord.conf文件及一个supervisord.d文件目录
pip install supervisor
或者 脚本命令(echo_supervisord_conf)生成配置文件
/usr/bin/echo_supervisord_conf


```ini
# 配置文件：supervisord.conf
[unix_http_server]
file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用
;chmod=0700    ;socket文件的mode，默认是0700
;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid

;[inet_http_server]         ;HTTP服务器，提供web管理界面
;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性
;username=user ;登录管理后台的用户名
;password=123  ;登录管理后台的密码

[supervisord]
logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log
logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小
logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份
loglevel=info   ;日志级别，默认info，其它: debug,warn,trace
pidfile=/tmp/supervisord.pid ;pid 文件
nodaemon=false  ;是否在前台启动，默认是false，即以 daemon 的方式启动
minfds=1024     ;可以打开的文件描述符的最小值，默认 1024
minprocs=200    ;可以打开的进程数的最小值，默认 200

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致
;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord

; [program:xx]是被管理的进程配置参数，xx是进程的名称
[program:xx]
command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令
autostart=true       ; 在supervisord启动的时候也自动启动
startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒
autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启
startretries=3       ; 启动失败自动重试次数，默认是3
user=tomcat          ; 用哪个用户启动进程，默认是root
priority=999         ; 进程启动优先级，默认999，值小的优先启动
redirect_stderr=true ; 把stderr重定向到stdout，默认false
stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB
stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10
; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）
stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out
stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程
killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程

;包含其它配置文件
[include]
files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件

# supervisord.d目录用来存放用户自定义的进程配置
[program:es]
command=/opt/software/elasticsearch/bin/elasticsearch
user=es
stdout_logfile=/opt/supervisor_test/run.log
autostart=true
autorestart=true
startsecs=60
stopasgroup=true
ikillasgroup=true
startretries=1
redirect_stderr=true
```

注意: supervisor不能监控后台进程，command 不能为后台运行命令,如gunicorn -D
**服务启动**
`supervisord -c /etc/supervisord.conf`



## 运维工具选型

|              | 简介                         | 优点 | 缺点 |
| ------------ | ---------------------------- | ---- | ---- |
| ActiveMQ     | 消息中间件。JMS。            |      |      |
| Apache Karaf | OSGI容器，可支持热插拔特性。 |      |      |
| Zabbix       | 开源监控系统。               |      |      |

备注：OSGI*i*(Open Service Gateway Initiative)~Java的动态模块化系统，,定义了一套模块应用开发的框架，提供了程序热更新的特性。*OSGI*容器实现方案如Apache Karaf、Knopflerfish, Equinox, and Apache Felix。



## 本章参考

**工具官网**

*  Ansible中文权威指南 [www.ansible.com.cn](http://www.ansible.com.cn)
* puppet  https://puppet.com/docs
* saltstack  https://docs.saltstack.com/en/latest/
* fabric https://fabric-chs.readthedocs.io/zh_CN/chs/tutorial.html#making-connections



**参考链接**

[1]. jenkins和docker实现自动化构建部署  https://blog.csdn.net/bingoxubin/article/details/78720976

[2]. Vagrant 入门指南 https://blog.csdn.net/qianghaohao/article/details/80038096

[3]. CentOS详解top命令各个数据的含义 https://blog.csdn.net/chaoluo001/article/details/79151905

[4]. watch OS and web server http://uptime.netcraft.com/up/graph?site

[5]. Hyper-V  https://docs.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v

* 自动化运维工具——puppet详解 https://www.cnblogs.com/keerya/p/8040071.html

* SaltStack学习 https://www.jianshu.com/p/624b9cf51c64



# 4 微服务运维

## 微服务部署方式

各微服务之间要互相隔离，独自部署。

* 虚拟环境virtual env（python)：每个微服务一个虚拟环境。

* Docker部署：每个微服务一个基础镜像（Dockerfile里的FROM项），命名为`项目名:1.0`

* K8S/ECS/docker-compose部署：一个组件管理一个微服务或组合微服务（若干紧耦合的微服务）。



## 本章参考



# 参考资料

## 参考书目
* [Python自动化运维 : 技术与最佳实践](https://book.douban.com/subject/26258735/) 刘天斯 / 机械工业出版社 / 2014-11-1
* 自动化运维软件设计实战 吴文豪 / 电子工业出版社 / 2015-7-1
* [SRE: Google运维解密](https://book.douban.com/subject/26875239/)【美】Betsy Beyer（贝特西 拜尔）等 / 孙宇聪 / 电子工业出版社 / 2016-10-1 / CNY 108.00



## 参考链接

* 百度百科-运维 [https://baike.baidu.com/item/%E8%BF%90%E7%BB%B4](https://baike.baidu.com/item/运维)
* 十大云运维监控工具横向评测 http://chuansong.me/n/1857260
* DevOps 标准体系发布及权威解读 [www.sohu.com/a/207491875_262549](http://www.sohu.com/a/207491875_262549)
*  Ubuntu 18.04 Bionic Beaver Linux上的默认root密码  https://ubuntuqa.com/article/7884.html
*  Linux操作运维问题  https://help.aliyun.com/knowledge_list/41090.html



## 运维相关的国际会议

以下是部分运维相关的国际会议，会议涉及运维及运维相关技术的交流学习。
* nsdi'14
* Percona live
* Velocity Oreilly web
* fcw'14
* LISA '14
* 35th IEEE S&P 2014
* SIGMOD/PODS ’14
* OSDI'14
* oow'13
* SRECON

