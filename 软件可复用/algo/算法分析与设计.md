| 序号  | 修改时间       | 修改内容                  | 修改人   | 审稿人   |
| --- | ---------- | --------------------- | ----- | ----- |
| 1   | 2010-1-6   | 创建                    | Keefe | Keefe |
| 2   | 2010-1-12  | 增加经典算法的总体介绍           | 同上    |       |
| 3   | 2010-1-15  | 背包问题的各种算法             | 同上    |       |
| 4   | 2011-2-25  | 增加工业界常用的领域特定算法        | 同上    |       |
| 5   | 2011-12-7  | 补充加密算法，加入Base64, md5等 | 同上    |       |
| 6   | 2016-7-21  | 增加指数设计章节              | 同上    |       |
| 7   | 2016-10-31 | 调整文档结构，增加广告算法章节。      | 同上    |       |
| 8   | 2016-12-15 | 将广告/推荐算法移到《大数据开发》     | 同上    |       |
| 9   | 2018-4-1   | 将广告算法移回此文档。           | 同上    |       |
| 10  | 2018-5-1   | 将加密算法从《安全开发》迁移到这。     | 同上    |       |
| 11  | 2018-9-3   | 更新加密AES算法细节。          | 同上    |       |
| 12  | 2018-10-27 | 将非数值和工业界领域算法移出单独成文。   | 同上    |       |
|     |            |                       |       |       |

<br><br><br>

---

# 目录

[TOC]

[目录... 1](#_Toc528412290)
[1  概述... 3](#_Toc528412291)
[1.1  算法课程介绍... 3](#_Toc528412292)
[1.2  算法学习建议... 3](#_Toc528412293)
[2 算法分析方法... 5](#_Toc528412294)
[2.1  算法分析方法综述... 5](#_Toc528412295)
[2.1.1    渐进表达式分析... 5](#_Toc528412296)
[2.1.2    解递推方程... 7](#_Toc528412297)
[2.2   计算复杂性（算法复杂性度量）... 8](#_Toc528412298)
[2.2.1    估计函数的阶（算法复杂度）... 8](#_Toc528412299)
[2.2.2    NP完全性NP-Complete. 9](#_Toc528412300)
[2.2.3    常见算法的复杂度... 10](#_Toc528412301)
[2.3   本章参考... 10](#_Toc528412302)
[3 算法设计方法... 11](#_Toc528412303)
[3.1   蛮力法... 11](#_Toc528412304)
[3.2   分冶法... 11](#_Toc528412305)
[3.3   动态规划法dynamic programming. 11](#_Toc528412306)
[3.4   贪心法Greedy. 12](#_Toc528412307)
[3.5   回溯法backtrack. 12](#_Toc528412308)
[3.6   分支  ... 13](#_Toc528412309)
[3.7   随机化算法random.. 13](#_Toc528412310)
[3.8  算法设计技术比较... 13](#_Toc528412311)
[求解组合优化问题的算法比较... 13](#_Toc528412312)
[算法设计方法间的关联... 14](#_Toc528412313)
[3.9  算法设计实现技巧... 14](#_Toc528412314)
[3.10     本章参考... 14](#_Toc528412315)
[4 算法经典问题... 15](#_Toc528412316)
[4.1   背包问题（限制总容量，物品价值最大）... 15](#_Toc528412317)
[4.2   0-1背包问题... 19](#_Toc528412318)
[4.3   N皇后问题... 19](#_Toc528412319)
[4.4   斐波那契（Fibonacci）数列... 21](#_Toc528412320)
[4.5   作业调度问题... 23](#_Toc528412321)
[4.6   旅行商问题TSP. 24](#_Toc528412322)
[4.7   本章参考... 24](#_Toc528412323)
[参考资料... 25](#_Toc528412324)
[附录... 25](#_Toc528412325)

 表目录
[表格 1 一些相关的渐近符号__ 6](#_Toc528412326)
[表格 2常见函数的阶__ 8](#_Toc528412327)
[表格 3 组合优化问题的算法比较表__ 13](#_Toc528412328)

 图目录
[图 1 《算法导论》中三个渐近记号θ-O-Ω的图例... 5](#_Toc528412329)

<br>

---

# 1  概述

## 1.1  算法课程介绍

 基本目的  掌握组合算法设计的基本技术掌握组合算法设计的基本技术
 掌握算法分析的基本方法
 了解计算复杂性理论的基本概念及其应用

 课程内容  顺序算法设计的基本技术顺序算法设计的基本技术
 分治策略 动态规划
 回朔算法 贪心法
 概率算法
 顺序算法分析的基本方法
评价算法的标准算法复杂性的估计
问题复杂性的下界算法分析的实例
计算复杂性理论的基本概念
 Turing机计算复杂性的概念
NP完全性理论及其应用

教材与参考书教材与参考书

1. 计算机算法设计与分析（第 2 版），王晓东 电子工业出版社 2004.7

2. Algorithm Design,  JonKleinberg, EvaTardos , 清华大学出版社2006

3. Introduction to Algorithms, Second Edition  Thomas H. Cormen , 1998

4. 计算机和难解性 NP完全性理论导引  M.R , 张立昂等译， 科学出版社 1987
   
   学习安排  以课上讲授为主
   成绩评定
   平时成绩 50%平时成绩 ： 50%
   期末笔试：50%

## 1.2  算法学习建议

参考：算法学习建议 http://www.cppblog.com/Leon916/archive/2008/07/06/55480.html
一般要做到50行以内的程序不用调试、100行以内的二分钟内调试成功.acm主要是考算法的，主要时间是花在思考算法上，不是花在写程序与debug上。
 下面给个计划你练练：

第一阶段：  练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，
 因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打
 出来.
  1.最短路(Floyd、Dijstra,BellmanFord)
  2.最小生成树(先写个prim,kruscal要用并查集，不好写)
  3.大数（高精度）加减乘除
  4.二分查找. (代码可在五行以内)
  5.叉乘、判线段相交、然后写个凸包.
  6.BFS、DFS,同时熟练hash表(要熟，要灵活,代码要简)
  7.数学上的有：辗转相除（两行内），线段交点、多角形面积公式.
  8.调用系统的qsort, 技巧很多，慢慢掌握.
  9.任意进制间的转换

第二阶段：
    练习复杂一点，但也较常用的算法。
例如：

 1. 二分图匹配（匈牙利），最小路径覆盖
 2. 网络流，最小费用流。
 3. 线段树.
 4. 并查集。
 5. 熟悉动态规划的各个典型：LCS、最长递增子串、三角剖分、记忆化dp
 6. 博弈类算法。博弈树，二进制法等。
 7. 最大团，最大独立集。
 8. 判断点在多边形内。
 9. 差分约束系统.
10. 双向广度搜索、A算法，最小耗散优先.
第三阶段：
    前两个阶段是打基础，第三阶段是锻炼在比赛中可以快速建立模型、想新算法。这就要平时多做做综合的题型了。
 1. 把oibh上的论文看看（大概几百篇的，我只看了一点点，呵呵）。
 2. 平时扫扫zoj上的难题啦，别老做那些不用想的题.(中大acm的版主经常说我挑简单的来
做:-P )
 3. 多参加网上的比赛，感受一下比赛的气氛，评估自己的实力.
 4. 一道题不要过了就算，问一下人，有更好的算法也打一下。
 5. 做过的题要记好 :-)

<br>

# 2 算法分析方法

## 2.1  算法分析方法综述

说明：在算法课程中，log n = log 2 n = lg n(即缺省logn, lgn均指底数为2的对数函数。 指数为e是为自然对数，用在很多特殊场合。

### 2.1.1   渐进表达式分析

 f(n)=O(g(n)).
 f(n)= Ω (g(n)).
 f(n)=Θ (g(n))
 f(n)=o(g(n)).
渐进分析法最常用的表示方法是用于描述函数渐近行为的数学符号。
算法的 渐近复杂度 就是忽略掉低阶项以及常数系数（常数是指数的除外，如n^2n,这里的2就不能忽略）来比较最高阶的项。如果从严格的数学定义出发，则需要引入三个渐近符号（符号的详细定义图请参见《算法导论》第3章函数的增长）：O、Ω、θ、，分别估计了函数的 渐近上界、渐近下界和  渐近确界 。

* Θ
* O [大O符号](http://baike.baidu.com/item/大O符号/656100)是由德国[数论](http://baike.baidu.com/item/数论)学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《[解析数论](http://baike.baidu.com/item/解析数论/2281979)》（ Analytische Zahlentheorie ）首先引入的。而这个记号则是在另一位德国数论学家[艾德蒙·朗道](https://wc.yooooo.us/w/index.php?title=艾德蒙·朗道&action=edit&redlink=1)（Edmund Landau）的著作中才推广的，因此它有时又称为 朗道符号 （Landau symbols）。代表“order of ...”（……阶）的大 O ，最初是一个大写的希腊字母'[Ο](https://wc.yooooo.us/wiki/Ο)'（omicron）， 现今用的是大写 [ 拉丁字母 ](https://wc.yooooo.us/wiki/拉丁字母) ‘ [ O ](https://wc.yooooo.us/wiki/O) ’  ，但从来不是阿拉伯数字‘0’ 。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2），它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。在数学中，它一般用来刻画被截断的[无穷级数](https://wc.yooooo.us/wiki/无穷级数)尤其是[渐近级数](https://wc.yooooo.us/w/index.php?title=渐近级数&action=edit&redlink=1)的剩余项；在计算机科学中，它在[分析](https://wc.yooooo.us/wiki/算法分析)[算法](https://wc.yooooo.us/wiki/算法)[复杂性](https://wc.yooooo.us/wiki/計算複雜性理論)的方面非常有用。
* Ω

![1574501955510](../../media/sf_reuse/algo/algo2_001.png)

图 1 《算法导论》中三个渐近记号θ-O-Ω的图例
说明：在每个部分中，n0是最小的可能值，大于n0的值也有效。
a) .θ记号限制一个函数在常数因子内 （给出了上界和下界） 。如果存在正常数n0、c1、 c2使得在n0右边f(n)的值永远在c0g(n)和c1g(n)之间，那么可以写成f= Θ (g(n))。
b) O记号给出一个函数在常数因子内的 上限 。如果存在正常数n0和 c使得在n0右边f(n)的值永远小于或等于cg(n)，那么可以写成f=O(g(n))。
c). Ω记号给出一个函数在常数因子内的 下限 。如果存在正常数n0和 c使得在n0右边f(n)的值永远大于或等于cg(n)，那么可以写成f=Ω(g(n))。

 定义  1 （来自《算法导论》）：  设 f   和 g   是定义域为自然数集 N   上的函数  ，  O(g(n)) 为一个函数集合。

* f(n)=Θ(g(n)) .   存在确界
* f(n)=O(g(n))   且   f(n)=Ω (g(n))
* f(n)=O(g(n)) ： 大 O 表示法 ， 存在上界
* 若存在正数 c 和 n0   使得对一切 n≥n0   有 0≤f(n)≤cg(n)
* f(n)= Ω(g(n)).   存在下界
* 若存在正数 c 和 n0   使得对一切 n≥n0   有 0≤cg(n)≤ f(n)
* f(n)=o(g(n)) ： 小 o 表示法 ，在低阶上无限趋近。
* 对所有正数 c<1   存在 n0   使得对一切 n≥n0   有 0≤f(n)<cg(n)

表格 1 一些相关的渐近符号

| 符号  | 定义                                                                            | 用途                                                                                                                                                                                                                                                                      |
| --- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     | 渐近上限                                                                          | 在数学中，它一般用来刻画被截断的[无穷级数](https://wc.yooooo.us/wiki/无穷级数)尤其是[渐近级数](https://wc.yooooo.us/w/index.php?title=渐近级数&action=edit&redlink=1)的剩余项；在计算机科学中，它在[分析](https://wc.yooooo.us/wiki/算法分析)[算法](https://wc.yooooo.us/wiki/算法)[复杂性](https://wc.yooooo.us/wiki/計算複雜性理論)的方面非常有用。 |
|     | asymptotically negligible（     ）                                              |                                                                                                                                                                                                                                                                         |
|     | 渐近下限 （[当且仅当](https://wc.yooooo.us/wiki/当且仅当)     ）                            |                                                                                                                                                                                                                                                                         |
|     | asymptotically dominant（[当且仅当](https://wc.yooooo.us/wiki/当且仅当)     ）          |                                                                                                                                                                                                                                                                         |
|     | asymptotically tight bound（[当且仅当](https://wc.yooooo.us/wiki/当且仅当)     且     ） |                                                                                                                                                                                                                                                                         |

定义2（来自维基百科）：设函数f ( n )代表某一算法在输入大小为n的情况下的工作量（效率），则在n趋向很大的时候，我们将f (n)与另一行为已知的函数g(n)进行比较：
 1）如果   0，则称f (n)在数量级上严格小于g(n)，记为f (n)=o( g(n))。
 2）如果 ，则称f(n)在数量级上严格大于g(n)，记为f (n)=w( g(n))。
 3）如果   c，这里c为非0常数，则称f (n)在数量级上等于g(n)，即f (n)和g(n)是同一个数量级的函数，记为：f (n)=Θ( g(n))。
 4）如果f (n)在数量级上小于或等于g(n)，则记为f (n)=O( g(n))。
 5）如果f(n)在数量级上大于或等于g(n)，则记为f (n)=Ω( g(n))。

这里我们假定f (n)，g (n)是渐近非负（非负单调）的，且极限存在。如果这个极限   不存在，则无法对f (n)和g (n)进行比较。在进行此种计算时，一个经常用到的技术是 洛必达（  L'Hopital  ）法则 。该法则由17世纪法国数学家Guillaume de L'Hopital发现（也有人认为是瑞士数学家Johann Bernoulli发现的）。该法则声称，两个函数的比率极限等于两个函数的导数的比率极限，这里当然假定两个函数的导数比率的极限存在，即有：

### 2.1.2   解递推方程

©  T(n) = aT(n/b) +  f(n)
©  T(n) =
方法:

1) 常系数线性递推方程的求解
   H (n) − a1H ( n − 1) − a 2 H ( n − 2) − ... − a k H ( n − k ) = 0
   H (0) = b0 , H (1) = b1 , H ( 2) = b2 , ... , H ( k − 1) = bk −1
   特征方程 x^k− a1 x^(k−1) − ... − ak = 0,
   特征方程的根称为递推方程的特征根
   a) 有重根;
   b) 无重根:

2) 迭代法

3) 公式法(齐次方程): 解特征根

4) 递归树法 (用来估计复杂度):  f(n)=常数或cn
   http://www.comp.nus.edu.sg/~xujia/mirror/algorithm.myrice.com/algorithm/complexity/chapter6_2.htm

5) master定理:
   设a ≥ 1, b > 1为常数, f ( n)为函数 , T ( n)为非负整数
   T ( n) = aT ( n / b ) + f ( n)   ),
   则有以下结果:
1. f ( n) = O( n llog b a −ε ), ε > 0, 那么T ( n) = Θ( nllog b a )

2. f ( n) = Θ( n log b a ), 那么T ( n) = Θ( nlogba logn)

3. f ( n) = Ω( n log b a + ε ), ε > 0, 且对于某个常数 c < 1和
   所有的充分大的 n有 af ( n / b ) ≤ cf ( n), 那么 T ( n) = Θ( f ( n))

## 2.2  计算复杂性（算法复杂性度量）

 数学基础

* 最大公约数，最小公倍数
* 质数

### 2.2.1  估计函数的阶（算法复杂度）

 备注：  Logx 是以10为底的对数； Lnx 是以常数项e (2.71828182845904) 为底的对数，称为自然对数。Logx与sqrt都可以将数值趋势降低，减少方差。
下列函数式中c表示常数， n表示未知数。
表格 2常见函数的阶

| 符号                                                        | 名称（阶）                                                                         | 示例                            |
| --------------------------------------------------------- | ----------------------------------------------------------------------------- | ----------------------------- |
| O(1)                                                      | [常数](https://wc.yooooo.us/wiki/常数)                                            | n= Θ(2^logn),  1= Θ(n^1/logn) |
| O(logn)                                                   | [对数](https://wc.yooooo.us/wiki/对数)                                            | log(n!)=  Θ(nlogn)            |
|                                                           | [多对数](https://wc.yooooo.us/wiki/多對數)                                          |                               |
| O(n)                                                      | [线性](https://wc.yooooo.us/wiki/線性)，次线性                                        | n=Θ(2^logn), 1=Θ(n^1/logn)    |
|                                                           | 为[迭代对数](https://wc.yooooo.us/wiki/迭代對數)                                       |                               |
| O(nlogn)                                                  | [线性对数](https://wc.yooooo.us/wiki/線性對數)，或对数线性、拟线性、超线性                          |                               |
|                                                           | [平方](https://wc.yooooo.us/wiki/平方)                                            |                               |
|                                                           | [多项式](https://wc.yooooo.us/wiki/多项式)，有时叫作“代数”                                 | 幂函数n^c                        |
|                                                           | [指数](https://wc.yooooo.us/wiki/指数)，有时叫作“[几何](https://wc.yooooo.us/wiki/等比数列)” | O (cn)                        |
| O(n!)                                                     | [阶乘](https://wc.yooooo.us/wiki/阶乘)，有时叫做“组合”                                   |                               |
| 备注：[复杂度](http://baike.baidu.com/item/复杂度)与时间效率的关系：        |                                                                               |                               |
| c < log2n < n < n log2n < n2 < n3 < 2n < 3n < n! （c是一个常量） |                                                                               |                               |
| --------------------------                                | --------------------------                                                    | -------------                 |
| 较好 一般 较差                                                  |                                                                               |                               |

> 其中c是一个常量，如果一个算法的复杂度为c 、log2n、n、 n log2n，那么这个算法时间效率比较高 ，如果是 2n,3n,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。

算法复杂度 ，即算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。一个问题本身也有它的复杂度，如果某个算法的复杂度到达了这个问题复杂度的下界，那就称这样的算法是最佳算法。

 一些规则（引自：时间复杂度计算)
1） 加法规则
T(n,m) = T1(n) + T2(n) = O (max (f(n),g(m))
2） 乘法规则
T(n,m) = T1(n)   T2(m) = O (f(n)   g(m))
3） 一个特例（问题规模为常量的[时间复杂度](http://baike.baidu.com/item/时间复杂度/1894057)）
在大O表示法里面有一个特例，如果T1(n) = O(c）， c是一个与n无关的任意常数，T2(n) = O (f(n)) 则有
T(n) = T1(n)   T2(n) = O (c f(n)) = O(f(n))
也就是说，在大O表示法中，任何非0正常数都属于同一[数量级](http://baike.baidu.com/item/数量级)，记为O⑴。

### 2.2.2  NP完全性NP-Complete

NP完全性，计算复杂性理论中的一个重要概念，它表征某些问题的固有复杂度。一旦确定一类问题具有NP完全性时，就可知道这类问题实际上是具有相当复杂程度的困难问题。

P和NP对于一个问题，如果存在一个图灵机，对这个问题的任何实例，都能给出回答，那么这个问题就称作可解的；如果存在一个图灵机，又存在一介多项式P，在给定问题的实例后（设n是给定实例在0、1编码下的长度)，这个图灵机能在P(n)步内给出回答,那么该问题称作多项式时间可解的。

图灵机可分为确定型和非确定型。确定型图灵机在多项式时间内可解决的全部问题类记作 P。非确定型图灵机在多项式时间内可解决的全部问题类，记作NP。NP完全问题就是NP中最难问题的一种形式化。NP完全问题对于一个问题q0,如果q0属于NP，且NP中任意一个问题，都能够多项式时间归约到q0，则称q0为NP完全的，或q0具有NP完全性。

 下面是若干有代表性的  NP  完全问题。
① 顶点覆盖 问题:给定一个图G=(V，E),V为顶点集合,E为边集合，又给定一个正整数K。问V是否有一个子集V′,其顶点数不超过K，并使G中每条边都能被V′覆盖，即每条边的两个顶点中至少有一个在V′中。
② 三维 匹配问题：三个班级，各有K人,共同参加某项活动。活动中，要求三人一组，组中每班一人。三人彼此认识的组称为相识组。假定已知全部可能的相识组,问从中能否选出K个相识组，使得每人能参加且仅能参加一个相识组。
③ 分割 问题：给定一堆自然数, 是否能将它们分成两部分，使得这两部分自然数各自的和彼此相等。
④带优先次序的调度问题:有m个处理机和一个任务集合，每个任务的执行时间为1,已知任务间的优先次序（不一定每对任务间都有优先次序）和一个截止时间D。问是否有一个m个处理机的调度方法，满足给定的优先次序，且在截止时间D以前结束全部任务。
⑤可满足性问题：对任意给定布尔表达式，是否可对式中各变元赋予真值和假值，使该表达式的值为真。
可满足性问题是历史上第一个NP完全问题，它由S.A.库克于1971年提出。

 意义
NP完全性的研究在理论上有重要意义。已经证明，只要有一个NP完全问题属于P,则NP中一切问题都属于P。实际上,NP中任何一个问题都可以多项式时间归约到这个NP完全问题，而该问题又可在多项式时间内解决,故NP中任何问题都可在多项式时间内解决。因此,只要能证明任何一个NP完全问题属于P,就能推出NP=P。
NP完全性的研究在实践中有重要指导作用。在算法设计和分析过程中,如果已证明某问题是NP完全的,这就意味着面临的是一个难于处理的问题。对于它，要找出一个在计算机上可行的（即多项式时间的）算法是十分困难的,甚至可能根本找不到(因为很可能有NP厵P)。因此，对于NP完全问题，最好是去寻找近似解法，或者针对该问题的某些有实用价值的特殊情况，寻找多项式时间算法。

### 2.2.3  常见算法的复杂度

详见 《高级数据结构和常用算法小结》相关章节。

<br>

## 本章参考

[1]. 《算法导论》第3章函数的增长
[2]. 大O表示法-百度百科 [http://baike.baidu.com/item/%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95](http://baike.baidu.com/item/大O表示法)
[3].   算法分析：大O符号/大Ω符号/大Θ符号/小o符号/小w符号http://www.aichengxu.com/suanfa/2422583.htm

<br>

# 3  算法设计方法

## 3.1  蛮力法

 性质 :  遍历所有情况
 常用方法：   枚举法，循环遍历
 范例 :  百钱百鸡问题
 伪码： 无

## 3.2  分冶法

 性质 : 顺序划分, 平衡原则
 范例 : 快速排序, strasen矩阵乘法...
 伪码：

```c
procedure DivideAndMerge(s)
{
  if (|s| < t) then   //当问题集小于某个规模时，直接求问题解
    Adhoc(s);
  else
  {
    divide s into small subset s1, s2...si...sk;
    for i<--1 to k do
      y[i]<--DivideAndMerge(s[i])
    return Merge(y1, y2,...yi,...yk);
    }
}
```

说明：|s|为问题s的规模，t为问题的分解尺度，Adhoc(si)分冶法求解函数，功能是解子问题并返回子问题的解，Megre(y1,y2,,,)为解的归并函数.

## 3.3  动态规划法dynamic programming

 性质 :

* 最优子结构性质
* 重叠子问题性质

**步骤 :**
  a) 定义问题结构.
  b) 递推方程: 递归定义最优值
  c) 以 自底向上 的方式, 求解最优值. (可使用备忘录, 标记函数)
  d) 构造最优解.
   范例 : 矩阵连乘, 最长公共子序列...

## 3.4  贪心法Greedy

 性质 :

* 最优子结构性质

* 贪心选择性质

证明 :

* 数学归纳法: 步数归纳和规模归纳

* 交换论证
  范例 : 哈夫曼编码, 最小生成树, 单源最短路径
  伪码：
  
  ```C
  procedure GREEDY(A, n)
  {
  //初始解空间集solution为空
  solution <-- ⊙
  for i<--1 to n do
    x<--SELECT(A);
    if FEASIBLE( solution, x)  then
      solution<-- union (solution, x);
  return solution;
  }
  ```
  
  说明： A为问题集, n为问题集个数. solution为方案的解集合. 函数SELECT的功能是从A中选择一个输入, 把它的值赋给x并从A中消去它(如一个贪心选择). 函数FEASIBLE的功能是判断x是否可以包含在解微量中, union将x加入到解向量集.

## 3.5   回溯法backtrack

问题的解空间： 子集树和排列树
搜索策略： 深度优先
回溯策略：　递归回溯和秩代回溯
递归回溯 伪码：

```C
procedure BACKTRACK(int t)
{
  if (t  >n) Output(x);    //t为递归深度，n为总深度
  else{
    for i<-- f(n,t) to g(n,t) do   //可能值上界－＞下界
    {     x[t]<-- h(i);  //x[t]为当前回溯深度的选取情况，通常h(i)<--i
      if (Constraint(t) && Bound(t)
        BACKTRACK(t+1);
    }
  }
}
```

说明：t表示递归深度．n为总深度，　当t>n时，算法已搜索到叶子结点，则输出此次可行解．Constraint为限制函数, Bound为边界函数，当这二个函数返回都为true时，继续搜索下级节点，否则剪去此分支． f(n,t)第一个可能的值，g(n,t)最后一个可能的值。

迭代回溯 伪码： （非递归回溯）

```C
procedure IterativeBacktract(void)
{
}
```

## 3.6  分支

问题的解空间：
搜索策略： 广度优先

## 3.7  随机化算法random

性质：
范例：
伪码：

## 3.8  算法设计技术比较

### 求解组合优化问题的算法比较

表格 3 组合优化问题的算法比较表

| 技术   | 动态规划        | 分支限界(  回溯)      | 贪心法                 |
| ---- | ----------- | --------------- | ------------------- |
| 使用条件 | 优化原则   多步判断 | 多米诺性质   多步判断    | 贪心选择+优化原则   多步判断    |
| 选择依据 | 子问题结果       | 约束条件和界          | 局部最优性质              |
| 计算过程 | 看子问题结果自底向上  | 选择后生成子问题自顶向下    | 选择后生成子问题自顶向下        |
| 数据结构 | 二维表         | 树,队列            | 线性表                 |
| 解    | 一个最优解       | 一个和多个最优解        | 一个最优或近似解            |
| 关键问题 | 递推方程   复杂性高 | 设定代价函数   时间复杂性高 | 贪心选择性质证明   近似解的误差估计 |

### 算法设计方法间的关联

1）对问题进行分解： 分冶法和动态规划
2）多阶段解决问题： 贪心法，递推，递归和动态规划
3）尝试比较： 蛮力法，枚举法和递归回溯

## 3.9  算法设计实现技巧

1）使用数组

- 数组存储输出结果。
- 数组存储状态信息， 如回溯法中回溯过程；

2）递归的使用
 设计思想：将一个复杂问题转化为与原问题相似的规模较小的问题。（问题分解）。 一步步求解小问题，再返回得到大问题的解。
 特点： 代码量少，可读性强，时间空间长，适用范围广，设计难度低。
 设计关键： 找出递归方程和递归终止（边界）条件。
 实例： hanoi汉诺塔问题，全排列permute，全组合combine等

<br>

## 本章参考

# 4 算法经典问题

## 4.1  背包问题（限制总容量，物品价值最大）

 问题描述 ：有不同价值、不同重量的物品n件，求从这n件物品中选取一部分物品的选择方案，使选中物品的总重量不超过指定的限制重量，但选中物品的价值之和最大。
设n个物品的重量和价值分别存储于数组w[ ]和v[ ]中，限制重量为tw。
 说明 ： 此外价值最大，也可以是利润最大，属于同一类问题。
问题扩展1：n件物品有重复的，则物品种类件数<n，为整数规划问题。
问题扩展2：物品可以拆零，可选取部分。
问题扩展3：物品不可拆零，要么选中要么不选，为0-1规划问题。
问题扩展4： 加入了体积限制，成为二限制一目标的问题集。

算法1：遍历枚举法
时间复杂度最高，最笨的算法

算法2  ：贪心法
思路： 1)贪心选择策略： 将物品按 单位价值 ( v[i]/w[i]) 按降序排列(贪心选择), 然后从头开始选择物品中,若物品加入后超重,则停止选择.  2）证明其贪心选择性质和最优子结构性质。
时间复杂度： 主要时间开销是在排序。  O (nlogn) +  O (n) +  O (n) =  O (nlogn)
Tips： 0-1背包问题用贪心选择策略可能得不到最优解，因为无法保证将背包装满，可能有空余空间浪费。
 伪码：

```C
procedure Knapsack(tw, n, w[], v[])
{
    //b[]记录原有w[]的位置, cw为当前重量
    SelectSort( A, n, b);
    for i<--1 to n do  and cw+w[b[i]]  < tw
    cw<--cw + w[b[i]];
}
```

源码：

```C
/*
   function： knapsack(N, tw, w[], v[])
   method： Greedy
input：
N=4, tw=12
物品 0 1 2 3
重量w 5 3 2 1
价值v 4 4 3 1
output：
*/
#include <stdio.h>
#define N 4
static int tw = 10;
int v[N] = { 6, 9, 3, 1 };
int w[N] = { 5, 3, 2, 1 };
int b[N];
int v1[N] = { 6, 9, 3, 1 };
int main ()
{
    int i,j;
    int sw = 0, sv = 0, max;
    for ( i = 0; i < N; i++)
   sw += w[i];
    if (sw <= tw)
    {
   printf ("whole chooosen");
   return 0;
    }
    //贪心法 select sort and save index
    for ( i = 0; i < N; i++)
    {
   max = 0;
   for ( j = 1; j < N; j++)
  if (v1[j] / w[j] > v1[max] / w[max])
      max = j;
   v1[max] = 0;
   b[i] = max;
    }
    for (i = 0, sw = 0; (sw+w[b[i+1]]) <= tw && i < N; i++)
    {
   sw += w[b[i]];
   sv += v[b[i]];
    }
    //
    //if(s!=m) w[b[i-1]]=w[b[i-1]]-(s-m)
    //
    for ( j = 0; j < i - 1; j++)
   printf ("choose b[j]=%d, weigh=%dn", b[j], w[b[j]]);
    printf ("total weight=%d, value=%dn", sw, sv);
    return 0;
}
```

算法3：动态规划的递归实现
思路：   生成个递推公式。

1) 递推公式：选择价值最大MAX｛选中，没选中）；
   2）出函数： n=0, return 0;
   时间复杂度：  O (2^n)
   伪码：

```C
Procedure Knapsack(tw, n)
 if n=0 return 0;
 max1 = Knapsack(tw, n-1);  // no select
 max2 = Knapsack(tw-w[n],  n-1) +v[n];   //have selected
 return MAX(max1, max2)
```

源码：

```C
/*
   function： knapsack(tw, n)
   method： dynamic programming
  */
int  knap (int tw, int n)
{
  if (n == 0)
    return 0;
  int max1, max2, max;
  max1 = knap (tw, n - 1);    //no select

  if (tw >= w[n])
    max2 = knap (tw - w[n], n - 1) + v[n]; //have selectd
  if (max1 > max2)
    max = max1;
  else
    max = max2;
  return max;
}
```

算法4： 回溯法＋限界
思路：   1）解向量空间：子集树； 2）搜索策略：深度优先； 3）限界函数：已搜索完分支i=n 或者物品超重cw < tw； 4）可选优化：背包问题可加入贪心选择策略，用最小堆存储物品（单位价值最大的）
时间复杂度：
伪码：

```C
int x[N];  //record node select status
procedure SNAP4(i)
 if i=n   //leaf node
  for I to n
  sum+=x1[i]   v[i];
  if(sum>max)
   max=sum; 并记下此分支的选取情况x[i]=x1[i]
  return;

  x[i]<--0;    //no select
  SNAP(i+1);  //
  if(cw+w[i] <tw)
   x[i]=1;    //have selected,
   cw+=w[i];
   SNAP(i+1);
   x[i]=0;
   SNAP(i+1);  //for backtrack
```

源码：

```C
int knap (int i)
{      //sum： the totoal value
  int sum = 0, j;
  if (i == N )   //leaf node
    { count++;  //record a branch
 for (j = 0; j < N; j++)
  sum += x1[j]   v[j];
  if (sum > max)
    {
      max = sum;
      for (j = 0; j < N; j++)
   x[j] = x1[j];
    }
 return 0;
    }

  x1[i] = 0;   //first unselected
  knap (i + 1);
  if (cw + w[i] <= tw)    //
    {
 x1[i] = 1;      //have selected
 cw += w[i];
 knap (i + 1);
 x1[i] = 0;      //for backtrack
 cw -= w[i];
    }
}
```

算法5： 分支
思路： 1）解向量空间：子集树； 2）搜索策略：广度优先； 3）限界函数：已搜索完分支i=n或者物品超重cw < tw； 4）可选优化：背包问题可加入贪心选择策略，用最小堆存储物品（单位价值最大的）
时间复杂度：  O (nm)
伪码：

## 4.2  0-1背包问题

 问题描述 ： 要求装入背包的物品时, 对每种物品i只有两种选择： 即装入背包或不装入背包, 不能将物品i装入背包多次, 也不能只装入部分的物品i.   X={0, 1}， 即 0-1  背包问题 。
解决思路：  在上面背包问题的基础上，考虑每个物品只有两种选择，选中或不选。

## 4.3  N皇后问题

 问题描述 ：求出在一个n×n的棋盘上，放置n个不能互相捕捉的国际象棋“皇后”的所有布局。 这是来源于国际象棋的一个问题。皇后可以沿着纵横和两条斜线4个方向相互捕捉。如图所示，一个皇后放在棋盘的第4行第3列位置上，则棋盘上凡打“×”的位置上的皇后就能与这个皇后相互捕捉。

**算法1：递归回溯 **
思路：
时间复杂度：
伪码：

```C
procedure PUT( t)
 if t>n  //leaf node
  OUTPUT();
  for(i=0; i<NUM; i++)
    queen[i]=i;   //record data
    if( ! CHECK(i) )
     PUT(t+1);
```

说明： OUTPUT为问题解输出函数，输出queen[]； CHECK为限制函数，限制不同行，不同列，不同对角线；PUT为实现主函数，PUT(0)从根结点开始遍历。

**算法2：非递归回溯 **
源码：

```C
#include <stdio.h>
#include <stdlib.h>

#define max 8
int queen[max], sum=0;  //  max为棋盘最大坐标

void show()  //  输出所有皇后的坐标
{
    int i;
    for (i = 0; i < max; i++)
    {
   printf("(%d,%d) ", i, queen[i]);
    }
    printf("\n");
    sum++;
}

int check(int n)  //  检查当前列能否放置皇后
{
    int i;
    for (i = 0; i < n; i++)  //  检查横排和对角线上是否可以放置皇后
    {
   if (queen[i] == queen[n] || abs(queen[i] - queen[n]) == (n - i))
   {
  return 1;
   }
    }
    return 0;
}

void put1(int n) //  回溯尝试皇后位置,n为横坐标
{
    int i;
    for (i = 0; i < max; i++)
    {
   queen[n] = i; //  将皇后摆到当前循环到的位置
   if (!check(n))
   {
  if (n == max - 1)
  {
      show(); //  如果全部摆好，则输出所有皇后的坐标
  }
  else
  {
      put1(n + 1); //  否则继续摆放下一个皇后
  }
   }
    }
}

void put(int n) //  回溯尝试皇后位置,n为横坐标
{
    int i;
    if (n>max-1)  show();  //leaf node
    for (i = 0; i < max; i++) //排列树，0--7
    {
   queen[n]=i;
   if ( !check(n) ) //限制函数
  put(n+1);
    }
}

int main()
{
    put(0); /  从横坐标为0开始依次尝试  /
    printf("sum=%d\n", sum);
    //system("pause");
    return 0;
}
```

## 4.4  斐波那契（Fibonacci）数列

 问题描述 ：古典题目,有一对兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。假设所有的兔子都不死，问每个月的兔子总数为多少。
对应的数列就是斐波那契(Fibonacci)数列： F(0)=0,F(1)=1,F(n)=F(n-1)+F(n-2)(n> 1).
 思路 ： 学习到了循环语句后老师就出了母牛问题给我们做。题目和兔子问题类似,思路也相同,程序显得相当简单。下面钱能给出了四个解决斐波那契(Fibonacci)数列的程序：
算法1：递归
时间复杂度：  O(2^n)

```C
int fibo1(int n)
{
    if(n==0) return 0;
    if(n==1) return 1;
    return fibo1(n-1)+fibo1(n-2);
}
```

算法2：非递归
时间复杂度：  O(n^2)

```C
int fibo2(int n)
{
    int a=0,c;
    for(int b=1,c,i=2; i<=n; ++i)
        c=a+b,a=b,b=c;
    return c;
}
```

算法3 ：矩阵法
时间复杂度：O(n)

```c++
int fibo3(int n)
{
    vector<int> v(n+1,0); v[1]=1;
    for(int i=2; i<=n; ++i)
    v=v[i-1]+v[i-2];
    return v[n];
}
```

算法4：公式法
时间复杂度：  O (1)

```C
int fibo4(int n)
{
    return (pow((1+sqrt(5.0))/2,n)-pow((1-sqrt(5,0))/2,n))/sqrt(5.0);
}
```

**python语法实现**

yield实现

```python
def fib_yield_while(max):
    a, b = 0, 1
    while max > 0:
        a, b = b, a + b
    max -= 1
    yield a


def fib_yield_for(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
        yield a


def test3():
    for i in fib_yield_for(10):
        print(i, end=' ')
```

生成器类实现

```python
class Fibonacci(object):
    """斐波那契数列迭代器"""

    def __init__(self, n):
        """
        :param n:int 指 生成数列的个数
        """
        self.n = n
        # 保存当前生成到的数据列的第几个数据，生成器中性质，记录位置，下一个位置的数据
        self.current = 0
        # 两个初始值
        self.a = 0
        self.b = 1

    def __next__(self):
        """当使用next()函数调用时，就会获取下一个数"""
        if self.current < self.n:
            self.a, self.b = self.b, self.a + self.b
            self.current += 1
            return self.a
        else:
            raise StopIteration

    def __iter__(self):
        """迭代器的__iter__ 返回自身即可"""
        return self


def test2():
    fib = Fibonacci(10)
    for num in fib:
        print(num)
```

算法分析：

1. 递归算法：最好理解的算法，和人的思路相当接近，对应的数学描述很清晰，容易编程。但是在C++语言中是使用栈机制实现的，如果使用递归函数，将会占用大量的内存资源，对内存中的栈区进行掠夺，在大量调用递归函数之后很可能造成内存崩溃，就算不崩溃，也会是长时间的运算。在调用了clock函数后，计算出了递归函数的耗时，是四个函数中最大的。而且这是个致命的缺点。时间复杂度为O(2^n)(括号内为2的n次方)。

2. 循环函数算法：这个方法需要对整个数列有一定的把握，并且能看出其中的规律，用我们班的一位同学说的就是不停的赋值。说的很形象，这样就是一个循环的过程，每次调用fibo2，都会一次次循环，时间复杂度为O(n^2)(括号内为n的平方)

3. 循环向量函数算法：同算法2类似，都是以循环来解决问题，但是算法3用向量先分配了一定的空间来实现，然后逐个求得向量的元素，最后得到数列的第n项值，这样就比算法2耗费更多的时间来进行下标操作，所以耗时比算法2多。

4. 数学公式算法：使用一个数学公式来进行计算，几乎不耗什么时间，一次运算就可以得到结果，时间和n的取值没有太大关系，只和运算性能有关。

具体算法写出来后，首先排除算法1，这个算法太耗时，并且没有可取之处。其他三个算法是各有千秋，但是可以人为的测试时间：
环境1：在循环加到一百万次时，分别取n为15，30，45得出算法2是最优的，时间消耗最少，少于0.3秒，算法3从1.4秒增加到3秒，算法4基本不变，始终为2.1秒左右。这样我们就可以看出，算法2虽然比较复杂，但是效率最高，程序员追求的就是这个效果，让机器运算的最快。

环境2：在文件中读取自变量，比较算法2和算法3，文件中有一万个数据时算法2和算法3耗时几乎相同为1.7秒，但是文件中有三万个数据时算法2耗时5.6秒，算法3几乎没变，此时算法3显得更优。

## 4.5  作业调度问题

　在多道程序环境中，主存中有着多个进程，其数目往往多于处理机数量。这就要求系统能按照某种算法动态地把处理机分配给就绪队列中的一个进程，使之执行，分配处理机的任务是由处理机调度程序完成的。

 处理机调度
　　在多道程序系统中，一个作业被提交后必须经过处理机调度后，方能获得处理机执行。对于批量型作业而言，通常需要经历作业调度（也称为高级调度）和进程调度（也称为低级调度）两个过程才能获得处理机；而对于终端型作业而言，通常只需要经过进程调度就可以获得处理机。除了上述两种调度，操作系统中往往也设置了中级调度，用来提高内存的利用率。
　　作业：是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，而且配有一份作业说明书，系统就是根据该说明书来对程序的运行进行控制。前面所说的某种算法，就是我们后面会提到的几种常用调度算法。
　　高级调度（作业调度）：其主要功能就是根据某种算法，把外存上处于后备队列中的那些作业调入内存，也就是说，调度的对象是作业。
　　低级调度（进程调度）：用于决定就绪队列中的哪个进程应该获得处理机，然后再由分派程序执行把处理机分派给该进程的具体操作。
　　中级调度：主要目的是为了提高内存利用率和系统吞吐量。它的工作原理就是将暂时不能运行的进程调至外存上去，此时的状态称为挂起。相反当内存空闲时，再将他们调回内存，此时的状态称为就绪，挂在就绪队列上等待进程的调度。
为了评价算法的优劣，提出了不同的性能分析标准：

1. cpu利用率：
   　　cpu是计算机系统中最重要的昂贵的资源，所以应该尽可能使cpu保持工作状态；

2. 系统吞吐量：
   　　单位时间内cpu完成作业的数量，长作业需要消耗较长的处理机时间，所以会降低系统的吞吐量；

3. 周转时间：
    从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处理机上运行以及进行输入输出操作所花费时间的总和。
   
   - 周转时间=作业完成时间-作业提交时间
   - 平均周转时间=（作业1的周转时间+作业2的周转时间+…+作业n的周转时间）/n
   - 带权周转时间=周转时间/作业实际运行时间
   - 平均带权周转时间=（作业1的带权周转时间+…+作业n的带权周转时间）/n

4. 等待时间:
     是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。

5. 响应时间:
     是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。

常用的几种调度算法有：

* 先来先服务调度算法（FCFS  ）

* 短作业（进程）优先调度算法

* 时间片轮转调度算法（RR  ）

* 优先级调度算法（HPF  ）

* 多级反馈队列调度算法

* 高响应比优先调度算法

## 4.6  旅行商问题TSP

问题背景： 巡回销售员问题也称货郎担问题，是一个著名的NP完全问题。
问题描述：  旅行商问题，即TSP问题（Travelling Salesman Problem）。
假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路经的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。

<br>

## 本章参考

 [1]. 作业调度算法  [ http://www.cnblogs.com/Mr24/p/6692468.html ](http://www.cnblogs.com/Mr24/p/6692468.html)

<br>

# 参考资料

**参考书籍**
[1]:  王晓东 计算机算法设计与分析（第 2 版） 电子工业出版社 2004.7
[2]:  Thomas H. Cormen , Introduction to Algorithms, Second Edition  , 1998
[3]:  吕国英主编算法设计与分析 清华大学出版社 2006.3
[4]:  M.R.Garey and D.S.Johnson, Computers and Intractability, A Guide to Theory of NP-Completeness,W.H.Freeman and Co.,San Francisco,1979.

**参考文献**

[1]:  http://www.algosort.com/: "http://www.algosort.com/"

[2]:  [Google Technology](http://www.google.com/technology/)

[3]:  http://zh.wikipedia.org/zh-cn/并行计算 "并行计算"
[4]:  http://zh.wikipedia.org/zh-cn/%E6%BC%94%E7%AE%97%E6%B3%95 "算法"
[5]:  http://zh.wikipedia.org/zh-cn/并行计算 "并行计算"
[6]:  http://blog.csdn.net/wfg18801733667/article/details/52192495 "每个程序员都应该收藏的算法复杂度速查表"
[7]:  http://www.cppblog.com/Leon916/archive/2008/07/06/55480.html "算法学习建议"

<br>

# 附录
