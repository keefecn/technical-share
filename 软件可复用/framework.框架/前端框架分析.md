| 序号 | 修改时间   | 修改内容            | 修改人 | 审稿人 |
| ---- | ---------- | ------------------------------------- | ------ | ------ |
| 1    | 2019-12-15 | 创建。从《web框架》相关章节迁移成文。 | Keefe | Keefe |
| 2 | 2021-11-1 | 更新React/Vue章节 | 同上 |     |
| 3 | 2021-11-18 | 将前端概述章节迁移另文《前端技术》 | 同上 | |








---



[TOC]



---

# 1  前端概述

详见 《[前端技术](../../平台与编程语言/前端技术.md)》



# 2  前端框架

## 2.1  前端框架概述

前端框架主要指HTML+CSS+JS组成的框架库。此外还包括模板引擎。

前端框架模式： MVC + MVP + MVVM

1. MVC：Model(模型) + View(视图) + Controller(控制器)，主要是基于分层的目的，让彼此的职责分开。

View通过Controller来和Model联系，Controller是View和Model的协调者，View和Model不直接联系，基本联系都是单向的。用户User通过控制器Controller来操作模板Model从而达到视图View的变化。

2. MVP：是从MVC模式演变而来的，都是通过Controller/Presenter负责逻辑的处理+Model提供数据+View负责显示。

在MVP中，Presenter完全把View和Model进行了分离，主要的程序逻辑在Presenter里实现。

并且，Presenter和View是没有直接关联的，是通过定义好的接口进行交互，从而使得在变更View的时候可以保持Presenter不变。

MVP模式的框架：Riot.js。

3. MVVM：MVVM是把MVC里的Controller和MVP里的Presenter改成了ViewModel。Model+View+ViewModel。

View的变化会自动更新到Model, Model的变化也会自动同步到View上显示。

这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。

MVVM支持框架：Angular  React



### 前端框架列表

表格  前端框架列表（基于编程语言）

| 语言   | 框架名称                   | 简介                        | 特性                        |
| ------ | ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| php    | Smarty                     | 一个php模板引擎。更准确的说,它分开了逻辑程序和外在的内容,提供了一种易于管理的方法。 |                          |
| python | Jinja2                     | 设计思想来源于[Django](https://baike.baidu.com/item/Django/61531)的模板引擎，并扩展了其语法和一系列强大的功能。 | 完全支持[unicode](https://baike.baidu.com/item/unicode)，并具有集成的沙箱执行环境 |
| J2EE   | [Freemarker](https://baike.baidu.com/item/Freemarker) |                          |                          |
| JS  | Prototype                  | 轻量级好用的AJAX开发框架。              | 功能实用而且尺寸较小，适合中小型的Web应用。         |
| JS  | JQuery                     | 轻量级好用的AJAX开发框架。              |                          |
| JS  | Bootstrap                  | 来自 Twitter开源的前端框架。   |                          |
| JS  | React                      | 起源于 Facebook，用来构建UI。              |                          |
| JS  | Vue                     | 构建用户界面的渐进式框架。              | 只关注视图层， 采用自底向上增量开发的设计。         |
| JS  | D3                      | Data-Driven Documents，数据可视化框架。          |                          |
| JS  | ECharts                    | 百度开源的商业级数据图表。缩写来自Enterprise Charts。     |                          |



### 前端框架比较

表格 前端主要框架比较

| 框架名称      | 主要 平台 | 基础技术           | 布局 | CSS 版式 | 控件   | 特效   | 风格设置         |
| ------------- | --------- | ------------------ | ---- | -------- | ------ | ------ | ---------------- |
| Bootstrap     | 桌面端    | jQuery, LESS       | 丰富 | 丰富     | 丰富   | 丰富   | 手动配置         |
| jQuery        | 桌面端    | jQuery             | -    | -        | 丰富   | 丰富   | 预置/可视化配置  |
| jQuery Mobile | 移动端    | jQuery             | 丰富 | -        | 丰富   | 丰富   | 预置/可视化配置  |
| SenchaExtJS   | 桌面端    | Ext JS, Sass       | 丰富 | -        | 极丰富 | 极丰富 | 预置             |
| Sencha Touch  | 移动端    | HTML5              | 丰富 | -        | 丰富   | 丰富   | -                |
| Sencha GXT    | 桌面端    | Java, HTML5        | 丰富 | -        | 丰富   | 丰富   | -                |
| Dojo          | 桌面端    | Dojo Nano          | 丰富 | 丰富     | 极丰富 | 极丰富 | CSS 代码         |
| Dojo Mobile   | 移动端    | Dojo Nano          | 丰富 | -        | 丰富   | 丰富   | 内置与移动端匹配 |
| Mootools      | 桌面端    | Mootools Core      | -    | -        | 少量   | 少量   | -                |
| Prototype     | 桌面端    | Prototype          | -    | -        | 少量   | 丰富   | -                |
| YUI           | 桌面端    | YUI                | 丰富 | -        | 丰富   | 丰富   |                  |
| Foudation     | 移动端    | jQuery/Zepto, Sass | 丰富 | 丰富     | 丰富   | 丰富   |                  |
| Kissy         | 桌面端    | Kissy Core         | -    | -        | 丰富   | 少     | -                |
| Kissy Mobile  | 移动端    | Kissy              | -    | -        | 少     | 少     | -                |
| QWrap         | 桌面端    | QWrap              | -    | -        | -      | 少     |                  |
| Tangram       | 桌面端    | Tangram            | -    | -        | 少     | 少     |                  |



## 2.2  模板引擎

*模板引擎用于执行字符串插值。*

- [mustache.js](https://github.com/janl/mustache.js)：JavaScript 最精简的 {{mustaches}} 模板
- [handlebars.js](https://github.com/wycats/handlebars.js/)：Mustache 模板语言的扩展。
- [nunjucks](https://mozilla.github.io/nunjucks/)：Mozilla 出品，丰富且强大的 JavaScript 模板语言。
- [hogan.js](https://github.com/twitter/hogan.js)：是 Mustache 模板语言的编译器。
- [doT](https://github.com/olado/doT)：最快速简洁的 JavaScript 模板引擎，适用于 Node.js 和浏览器。
- [dustjs](https://github.com/linkedin/dustjs/)：适用于浏览器和 Node.js 的异步模板。
- [eco](https://github.com/sstephenson/eco/)：嵌入式的 CoffeeScript 模板。
- [JavaScript-Templates](https://github.com/blueimp/JavaScript-Templates)：轻量（小于 1KB）、快速、强大且无依赖的 JavaScript 模版引擎。
- [t.js](https://github.com/jasonmoo/t.js)：小巧的 JavaScript 模板框架，压缩后约为 400 字节。
- [Pug](https://github.com/pugjs/pug)：健壮的、优雅且功能丰富的 nodejs 模板引擎。`（曾用名：Jade）`
- [EJS](https://github.com/mde/ejs)：高效的 JavaScript 模板。
- [xtemplate](https://github.com/xtemplate/xtemplate)：可扩展的模板引擎，适用于 node.js 和浏览器。
- [marko](https://github.com/marko-js/marko)：基于 HTML 快速轻量的模板引擎，支持异步、流、自定义标签，支持 CommonJS 模块作为编译后输出，适用于 Node.js 和浏览器。
- [swig](https://github.com/paularmstrong/swig)：一款简单、强大、可扩展的基于 Node.js 和 浏览器的 JavaScript 模板引擎。`（已停止维护）`
- [EHTML](https://github.com/Guseyn/EHTML)：一款实现零编写 JavaScript 的 HTML 框架。



### Smarty (PHP)

  Smarty的特点之一是"模板编译"。意思是Smarty读取模板文件然后用他们创建php脚本。这些脚本创建以后将被执行。因此并没有花费模板文件的语法解析,同时每个模板可以享受到诸如Zend加速器(http://www.zend.com ) 或者PHP加速器(http://www.php-accelerator.co.uk )。这样的php编译器高速缓存解决方案。

Smaty的一些特点:

*  非常非常的快!

*  用php分析器干这个苦差事是有效的

*  不需要多余的模板语法解析,仅仅是编译一次
*  仅对修改过的模板文件进行重新编译
*  可以编辑'自定义函数'和自定义'变量',因此这种模板语言完全可以扩展
*  可以自行设置模板定界符,所以你可以使用{}, {{}}, <!--{}-->, 等等
*  诸如 if/elseif/else/endif 语句可以被传递到php语法解析器,所以 {if ...} 表达式是简单的或者是复合的,随你喜欢啦
*  如果允许的话,section之间可以无限嵌套
*  引擎是可以定制的.可以内嵌php代码到你的模板文件中,虽然这可能并不需要(不推荐)
*  内建缓存支持
*  独立模板文件
*  可自定义缓存处理函数
*  插件体系结构



安装Smarty发行版在/libs/目录

**Smarty库文件**

```shell
Smarty.class.php
Smarty_Compiler.class.php
Config_File.class.php
debug.tpl
/core/*.php (all of them)
/plugins/*.php (all of them)
```



**一个smarty的应用实例：**

法1：使用全路径

`require('/usr/local/lib/php/Smarty/Smarty.class.php');`

法2：使用'SMARTY_DIR'的php常量作为它的系统库目录

```php
define('SMARTY_DIR','/usr/local/lib/php/Smarty/');
require(SMARTY_DIR.'Smarty.class.php');
```

法3：使用库路径

```php
require('Smarty.class.php');
$smarty = new Smarty;
```

创建`index.tpl`文件让smarty载入。这个文件放在 $template_dir目录里

```tpl
{* Smarty *}
Hello, {$name}!
```

说明：{* *}为注释。

实例：

```php
require('Smarty.class.php');

$smarty = new Smarty;
$smarty->assign('name','Ned');
$smarty->display('index.tpl');
```

结果：

在浏览器打开 index.php,你应该看到"Hello, Porky!"



### Jinja2 (Python)

```shell
$ pip show Jinja2
Name: Jinja2
Version: 2.11.3
Summary: A very fast and expressive template engine.
Home-page: https://palletsprojects.com/p/jinja/
Author: Armin Ronacher
Author-email: armin.ronacher@active-4.com
License: BSD-3-Clause
Location: e:\dev\python\venv\superset-py37-env\lib\site-packages
Requires: MarkupSafe
Required-by: Flask, Flask-Babel
```

Jinja2 是一个现代的，设计者友好的，仿照 Django 模板的 Python 模板语言。 它速度快，被广泛使用，并且提供了可选的沙箱模板执行环境保证安全，以 BSD 许可证授权。

[Flask](https://baike.baidu.com/item/Flask)使用jinja2作为框架的模板系统；使用django等其他Python web框架也可以方便的集成jinja2模板系统。

**特性:**

- 沙箱中执行
- 强大的 HTML 自动转义系统保护系统免受 XSS
- 模板继承
- 及时编译最优的 python 代码
- 可选提前编译模板的时间
- 易于调试。异常的行数直接指向模板中的对应行。
- 可配置的语法

**优点：**

1.  相对于Python原生string的Template，jinja2更加灵活，它提供了控制结构，表达式和继承等。
2.  相对于Mako，jinja2仅有控制结构，不允许在模板中编写太多的业务逻辑。
3.  相对于Django模板，jinja2性能更好。
4.  Jinja2模板的可读性很棒。



**示例**

```jinja2
{% extends "layout.html" %}    #layout.html文件

<title>{% block title %}{% endblock %}</title>
{% block body %}
  <ul>
  {% for user in users %}
    <li><a href="{{ user.url }}">{{ user.username }}</a></li>
  {% endfor %}
  </ul>
{% endblock %}
```



#### Jinja2语法

**基本语法**如下：

* 控制结构 {% %}：包括 for/if/with 等，用相应的endxx结束。

* 变量取值 {{ }}：变量{{}}相当于占位符，渲染时才填充/替换。支持所有的python数据类型。可以用`过滤器`修改变量值。

* 注释 {# #}：
* 宏macro/call：用endmacro结束
* set： 变量赋值



 for 循环块中你可以访问这些特殊的变量:

| 变量           | 描述                                         |
| :------------- | :------------------------------------------- |
| loop.index     | 当前循环迭代的次数（从 1 开始）              |
| loop.index0    | 当前循环迭代的次数（从 0 开始）              |
| loop.revindex  | 到循环结束需要迭代的次数（从 1 开始）        |
| loop.revindex0 | 到循环结束需要迭代的次数（从 0 开始）        |
| loop.first     | 如果是第一次迭代，为 True 。                 |
| loop.last      | 如果是最后一次迭代，为 True 。               |
| loop.length    | 序列中的项目数。                             |
| loop.cycle     | 在一串序列间期取值的辅助函数。见下面的解释。 |



**jinja2的过滤器**

变量可以通过“过滤器”进行修改，过滤器可以理解为是jinja2里面的内置函数和字符串处理函数。

表格 jinja2常用过滤器

| 过滤器名称  | 说明                                         |
| ----------- | -------------------------------------------- |
| safe        | 渲染时值不转义                               |
| capitialize | 把值的首字母转换成大写，其他子母转换为小写   |
| lower       | 把值转换成小写形式                           |
| upper       | 把值转换成大写形式                           |
| title       | 把值中每个单词的首字母都转换成大写           |
| trim        | 把值的首尾空格去掉                           |
| striptags   | 渲染之前把值中所有的HTML标签都删掉           |
| join        | 拼接多个值为字符串                           |
| replace     | 替换字符串的值                               |
| round       | 默认对数字进行四舍五入，也可以用参数进行控制 |
| int         | 把值转换成整型                               |

如何使用这些过滤器呢？ 只需要在变量后面使用管道(|)分割，多个过滤器可以链式调用，前一个过滤器的输出会作为后一个过滤器的输入。也可以如下使用:

```jinja2
{{ 'abc' | captialize  }}
# Abc #

{% filter upper %}
    This text becomes uppercase
{% endfilter %}
# this text becomes uppercase #
```



#### Jinja2模板继承

jinja2中最强大的部分就是模板继承。模板继承允许我们创建一个基本(骨架)文件，其他文件从该骨架文件继承，然后针对自己需要的地方进行修改。

jinja2模板继承重要关键字：

* block:  利用block关键字表示其包涵的内容可以进行修改。结束endblock
* extend: 继承块，可以导入文件路径。
* include:  用于包含一个模板，并在当前命名空间中返回那个文件的内容渲染结果。
* macro/call/import/from xx import xx  导入代码、模块等



以下面的骨架文件base.html为例：

```jinja2
<!DOCTYPE html>
<html lang="en">
<head>
    {% block head %}
    <link rel="stylesheet" href="style.css"/>
    <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
</head>
<body>
<div id="content">{% block content %}{% endblock %}</div>
<div id="footer">
    {% block  footer %}
    <script>This is javascript code </script>
    {% endblock %}
</div>
</body>
</html>
```

这里定义了四处 block，即：head，title，content，footer。那怎么进行继承和变量替换呢？一个子模板如下

```jinja2
{% extend "base.html" %}       {# 继承base.html文件 #}

{% block title %} Dachenzi {% endblock %}   {# 定制title部分的内容 #}

{% block head %}
    {{  super()  }}        {# 用于获取原有的信息 #}
    <style type='text/css'>
    .important { color: #FFFFFF }
    </style>
{% endblock %}

{# 其他不修改的原封不同的继承#}
```

说明：可以调用 super 来渲染父级块的内容，这会返回父级块的结果。



### Liquid

Jekyll的模板语言。详见  [Jekyll用户手册](../tools.工具/Jekyll用户手册.md)

https://liquid.bootcss.com/



## 2.3  AJAX

### 2.3.1   Prototype

Prototype是目前应用广泛的AJAX开发框架，其的特点是功能实用而且尺寸较小，非常适合在中小型的Web应用中使用。

[Prototype.js](http://baike.baidu.com/view/1112205.htm)是由Sam Stephenson写的一个JavaScript类库。该框架的设计思路巧妙，而且兼容标准的类库，能够帮助开发人员轻松建立有交互性]良好的web2.0特性[富客户端](http://baike.baidu.com/view/1330363.htm)页面。

开发Ajax应用需要编写大量的客户端JavaScript脚本，而Prototype框架可以大大地简化JavaScript代码的编写工作。更难得的是，Prototype具备兼容各个浏览器的优秀特性，使用该框架可以不必考虑[浏览器兼容性](http://baike.baidu.com/subview/6746126/6874381.htm)的问题。

Prototype对JavaScript的内置对象（如“String”对象、“Array”对象等）进行了很多有用的扩展，同时该框架中也新增了不少自定义的对象，包括对Ajax开发的支持等都是在自定义对象中实现的。Prototype可以帮助开发人员实现以下的目标：

（1）对字符串进行各种处理

（2）使用枚举的方式访问集合对象

（3）以更简单的方式进行常见的DOM操作

（4）使用CSS选择符定位页面元素

（5）发起Ajax方式的HTTP请求并对响应进行处理

（6）监听DOM事件并对事件进行处理
 　　“Prototype”框架功能详解—使用实用函数，“Prototype”框架的实现仅仅包含一个JavaScript即可，1.6版本的“[Prototype.js](http://baike.baidu.com/subview/1112205/1112205.htm)”的文件大小为127K字节，约4220行。在页面中应用的语法类似于：

```html
<script
type=”text/JavaScript” src=”inc"js"Prototype.js” ></script>
```

然后就可以在后继的脚本中享受该框架带来的便利了。



该框架中有很多预定义的对象和实用函数，可以将程序员从重复的打字中解放出来。

（1）使用“$()”函数。

（2）使用“$F()”函数。此函数是另一个大受欢迎的“快捷键”，能用于返回任何表单输入控件的值，比如多行文本框和下拉列表框等控件。此个方法也能用元素id或元素本身做为参数。

（3）使用“$A()”函数。此函数能将其接收到的单个的参数转换成一个Array对象。

（4）使用“$H()”函数。此函数把一些对象转换成一个可枚举的和联合数组类似的Hash对象。

（5）使用“$R()”函数。此函数是“new ObjectRange(lowBound,upperBound,excludeBounds)”的缩写，用于建立一个范围对象。

（6）使用“Try.these()”函数。“Try.these()” 方法用于调用不同的方法直到其中的一个成功。此函数把一系列的方法作为参数，并且按顺序的一个一个的执行这些方法，直到其中的一个成功执行。返回成功执行 的那个方法的返回值。“Try.these()”函数可以用于处理兼容性问题。



### 2.3.2   JQuery

JQuery是继[Prototype](http://baike.baidu.com/view/1217697.htm)之后又一个优秀的[JavaScript](http://baike.baidu.com/view/16168.htm)库。它是轻量级的js库 ，它兼容[CSS3](http://baike.baidu.com/view/1713027.htm)，还兼容各种浏览器（[IE](http://baike.baidu.com/subview/703/10271308.htm) 6.0+, [FF](http://baike.baidu.com/subview/31049/5089479.htm) 1.5+, [Safari](http://baike.baidu.com/subview/110484/5036395.htm) 2.0+, [Opera](http://baike.baidu.com/subview/10019/7098372.htm) 9.0+），JQuery2.0及后续版本将不再支持IE6/7/8浏览器。JQuery使用户能更方便地处理[HTML](http://baike.baidu.com/view/692.htm)（[标准通用标记语言](http://baike.baidu.com/view/5286041.htm)下的一个应用）、events、实现动画效果，并且方便地为网站提供[AJAX](http://baike.baidu.com/subview/1641/5762264.htm)交互。JQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。JQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需要定义id即可。

JQuery是一个兼容多浏览器的JavaScript库，核心理念是write less,do more(写得更少,做得更多)。JQuery在2006年1月由美国人John Resig在纽约的barcamp发布，吸引了来自世界各地的众多JavaScript高手加入，由Dave Methvin率领团队进行开发。如今，JQuery已经成为最流行的JavaScript库，在世界前10000个访问最多的网站中，有超过55%在使用JQuery。

JQuery是免费、开源的，使用MIT许可协议。JQuery的语法设计可以使开发更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用[Ajax](http://baike.baidu.com/view/1641.htm)以及其他功能。除此以外，JQuery提供API让开发者编写插件。其模块化的使用方式使开发者可以很轻松的开发出功能强大的静态或动态网页。

JQuery，顾名思义，也就是JavaScript和查询（Query），即是辅助JavaScript开发的库。





## 2.4  前端经典框架

表格 前端经典框架比较（Angular/Bootstrap/React/Vue）

| 框架                                   | Sponsor           | 开源时间 | 开源<br>协议 | 源码                                                         | 文档                                                         | 最新版本 | 简介                                                         | 优点               | 缺点                                  |
| :------------------------------------- | ----------------- | -------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ | ------------------ | ------------------------------------- |
| [Angular](https://angular.io/)         | Google, Huawei... | 2010     | MIT          | [angular/angular](https://github.com/angular/angular)        | [DOCS](https://angular.io/docs)                              | 12.2.9   | 横跨所有平台，快速的前端框架。                               | 各语种有专门站点。 | ~~性能上AngularJS依赖对数据做脏检查~~ |
| [Bootstrap](https://getbootstrap.com/) | Twitter           | 2011.8   | MIT          | [twbs/bootstrap](https://github.com/twbs/bootstrap)          | [Docs](https://getbootstrap.com/docs/5.1/) [Readme](https://github.com/twbs/bootstrap#readme) | 5.1.2    | Bootstrap 主要针对桌面端，Bootstrap3 提出移动优先。<br>Bootstrap 主要基于 jQuery 进行 JavaScript 处理，支持 LESS 来做 CSS 的扩展。 | jQuery+LESS        | IE6/7不友好                           |
| [React](https://reactjs.org/)          | Facebook          | 2013.5   | MIT          | [facebook/react](https://github.com/facebook/react)          | [Readme](https://github.com/facebook/react#readme)           | 17.0.2   | React 是一个用于构建用户界面的 JavaScript 库。React主要用于构建UI. | JSX                |                                       |
| [Vue.js](https://cli.vuejs.org )       | 阿里巴巴...       | 2014     | MIT          | [vuejs/vue-cli: 🛠️ Standard Tooling for Vue.js Development](https://github.com/vuejs/vue-cli) | [Readme](https://github.com/vuejs/vue-cli#readme)            | 4.5.13   | 基于 Vue.js 进行快速开发的完整系统.                          | 上手最容易。       |                                       |

> 备注：最新版本时间截止到2021.10.9



表格  前端三大框架比较

|            | Angular  |   React    |   Vue    |
| :--------: | :------: | :--------: | :------: |
|  组织方式  |   MVC    |   模块化   |  模块化  |
| *数据绑定* | 双向绑定 | *单向绑定* | 双向绑定 |
|  模板能力  |   强大   |    自由    |   自由   |
|   自由度   |   较小   |     大     |   较大   |
|    路由    | 静态路由 |  动态路由  | 动态路由 |
|    背景    |  Google  |  Facebook  | 阿里巴巴 |
|  开源时间  |   2010   |   2013.5   |   2014   |
|    文档    |   英文   |    英文    |  多语言  |
|  上手难度  |   ⭐⭐⭐    |    ⭐⭐⭐     |    ⭐⭐    |
|  App方案   |  lonic   |     RN     |   Weex   |

* 模块化：一切都是组件，组件实例之间可以嵌套。
* 模板：React模板就是JSX，JSX语法相当于一个变量，相当灵活。Vue支持模板语法和JSX语法。
* 路由：React使用React-router，Vue使用Vue-router，Angular中是静态的路由，而React4.x开始使用动态路由，Vue2.2之后也可以使用addRoutes来创建动态路由。
* React依赖Virtual DOM，而Vue.js使用的是DOM模板。



### Angular (2010)



### Bootstrap (2011)

Bootstrap来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。用于开发响应式布局、移动设备优先的 WEB 项目。

Bootstrap 是 2011年8月在 GitHub 上发布的开源产品。

**Bootstrap 包的内容**

- **基本结构**：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。这将在 **Bootstrap 基本结构** 部分详细讲解。

- **CSS**：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。这将在 **Bootstrap CSS** 部分详细讲解。

- **组件**：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。这将在 **布局组件** 部分详细讲解。

- JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。

- **定制**：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。



### React (2013)

React 是一个用于构建用户界面的 JavaScript 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。

React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。

React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。



**React** **特点**

1. 声明式设计  −React采用声明范式，可以轻松描述应用。
2. 高效  −React通过对DOM的模拟，最大限度地减少与DOM的交互。
3. 灵活  −React可以与已知的库或框架很好地配合。
4. JSX  −JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。
5. 组件Component   −通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。
6. 单向响应的数据流  −React 实现了单向响应（父组件流向子组件）的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。通过prop和state来实现。



第一个例子
```xml
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello React!</title>
    <script src="https://cdn.bootcss.com/react/15.4.2/react.min.js"></script>
    <script src="https://cdn.bootcss.com/react/15.4.2/react-dom.min.js"></script>
    <script src="https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js"></script>
  </head>
  <body>
    <div id="example"></div>
    <script type="text/babel">
   ReactDOM.render(
     <h1>Hello world!</h1>,
     document.getElementById('example')
   );
    </script>
  </body>
</html>
```



### Vue.js (2014)

Vue.js（读音 /vjuː/, 类似于 view），简称Vue，是一套构建用户界面的渐进式框架。

Vue 只关注视图层， 采用自底向上增量开发的设计。

Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。



第一个例子

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 菜鸟教程(runoob.com)</title>
<script src="https://cdn.bootcss.com/vue/2.2.2/vue.min.js"></script>
</head>
<body>
<div id="app">
  <p>{{ message }}</p>
</div>

<script>
new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!'
  }
})
</script>
</body>
</html>
```



## 2.5 可视化框架

参见  《[数据可视化](数据可视化.md)》相关章节。



## 2.6 其它框架

### Express

Express的特点

- 实现了路由功能
- 中间件功能
- 扩展了req和res对象
- 可以集成其他模版引擎



## 本章参考

*  Bootstrap   https://www.bootcss.com/
*  Bootstrap  [http://www.runoob.com/try/Bootstrap](http://www.runoob.com/try/bootstrap)
*  react http://react-china.org/
*  React 教程 http://www.runoob.com/react/react-tutorial.html
*  vue http://www.runoob.com/vue2/vue-tutorial.html
*  前端开发框架对比 https://www.cnblogs.com/liangxiaofeng/p/5253103.html
*  前端三大框架的对比 https://www.jianshu.com/p/64dad076dace
*  Jinja2中文文档  http://docs.jinkan.org/docs/jinja2/



# 3  Node.js

官网：https://nodejs.org/

## 入门篇

### 简介

Node.js是建立在谷歌Chrome的JavaScript引擎(V8引擎)的Web应用程序框架。Node.js在[官方网站](https://nodejs.org/)的定义文件内容如下：

Node.js® is a platform built on [Chrome's JavaScript runtime](http://code.google.com/p/v8/) for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.

Node.js自带运行时环境可在JavaScript脚本的基础上可以解释和执行(这类似于JVM的Java字节码)。这个运行时允许在浏览器以外的任何机器上执行JavaScript代码。由于这种运行时在Node.js上，所以JavaScript现在可以在服务器上执行。

Node.js还提供了各种丰富的JavaScript模块库，它极大简化了使用Node.js来扩展Web应用程序的研究与开发。

**Node.js =** **运行环境+ JavaScript库**



下图描述了 Node.js 的一些重要组成部分

   ![1574518074852](../../media/sf_reuse/framework/frame_web_nodejs_01.png)

图 2 Node.js Concept



**在哪里可以使用Node.js？**

以下是Node.js证明自己完美的技术的合作伙伴的领域。

*  I/O 绑定应用程序
*  数据流应用
*  数据密集型实时应用(DIRT)
*  JSON API的应用程序
*  单页面应用



**在哪些地方不要使用Node.js？**

不建议使用Node.js的就是针对CPU密集型应用。



**与node.js** **相关的工具**

*  gulp 基于 node 实现 Web 前端自动化开发的工具，利用它能够极大的提高开发效率。

*  ghost  node.js和ghost安装配置工具

*  grunt  node.js自动化项目构建工具



### 版本

Nodejs的版本兼容性较差，因此要熟悉各个版本的差异。

详细参见 https://nodejs.org/zh-cn/download/releases/

表格 Nodejs版本说明

| Version         | LTS     | Date       | V8         | npm     | N-M-V |                                                              |
| --------------- | ------- | ---------- | ---------- | ------- | ----- | ------------------------------------------------------------ |
| Node.js 17.0.0 |  | 2021-10-19 | 9.5.172.21 | 8.1.0 | 102 | [下载 ](https://nodejs.org/download/release/v17.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V17.md#17.0.0)[文档](https://nodejs.org/dist/v17.0.0/docs/api/) |
| Node.js 16.13.0 | Gallium | 2021-10-26 | 9.4.146.19 | 8.1.0 | 93 | [下载 ](https://nodejs.org/download/release/v16.13.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V16.md#16.13.0)[文档](https://nodejs.org/dist/v16.13.0/docs/api/) |
| Node.js 16.4.0 | Gallium | 2021-06-23 | 9.1.269.36 | 7.18.1  | 93    | [下载 ](https://nodejs.org/download/release/v16.4.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V16.md#16.4.0)[文档](https://nodejs.org/dist/v16.4.0/docs/api/) |
| Node.js 16.0.0  | Gallium | 2021-04-20 | 9.0.257.17 | 7.10.0  | 93    | [下载 ](https://nodejs.org/download/release/v16.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V16.md#16.0.0)[文档](https://nodejs.org/dist/v16.0.0/docs/api/) |
| Node.js 15.0.0  |         | 2020-10-20 | 8.6.395.16 | 7.0.2   | 88    | [下载 ](https://nodejs.org/download/release/v15.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V15.md#15.0.0)[文档](https://nodejs.org/dist/v15.0.0/docs/api/) |
| Node.js 14.18.1 | Fermium | 2021-10-12 | 8.4.371.23 | 6.14.15 | 83 | [下载 ](https://nodejs.org/download/release/v14.18.1/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.18.1)[文档](https://nodejs.org/dist/v14.18.1/docs/api/) |
| Node.js 14.17.1 | Fermium | 2021-06-15 | 8.4.371.23 | 6.14.13 | 83    | [下载 ](https://nodejs.org/download/release/v14.17.1/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.17.1)[文档](https://nodejs.org/dist/v14.17.1/docs/api/) |
| Node.js 14.0.0  | Fermium | 2020-04-21 | 8.1.307.30 | 6.14.4  | 83    | [下载 ](https://nodejs.org/download/release/v14.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.0.0)[文档](https://nodejs.org/dist/v14.0.0/docs/api/) |
| Node.js 13.0.0  |         | 2019-10-22 | 7.8.279.17 | 6.12.0  | 79    | [下载 ](https://nodejs.org/download/release/v13.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V13.md#13.0.0)[文档](https://nodejs.org/dist/v13.0.0/docs/api/) |
| Node.js 12.22.1 | Erbium  | 2021-04-06 | 7.8.279.23 | 6.14.12 | 72    | [下载 ](https://nodejs.org/download/release/v12.22.1/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V12.md#12.22.1)[文档](https://nodejs.org/dist/v12.22.1/docs/api/) |
| Node.js 12.0.0  |         | 2019-04-23 | 7.4.288.21 | 6.9.0   | 72    | [下载 ](https://nodejs.org/download/release/v12.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V12.md#12.0.0)[文档](https://nodejs.org/dist/v12.0.0/docs/api/) |
| Node.js 11.0.0  |         | 2018-10-23 | 7.0.276.28 | 6.4.1   | 67    | [下载 ](https://nodejs.org/download/release/v11.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V11.md#11.0.0)[文档](https://nodejs.org/dist/v11.0.0/docs/api/) |
| Node.js 10.24.1 | Dubnium | 2021-04-06 | 6.8.275.32 | 6.14.12 | 64    | [下载 ](https://nodejs.org/download/release/v10.24.1/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V10.md#10.24.1)[文档](https://nodejs.org/dist/v10.24.1/docs/api/) |
| Node.js 10.0.0  |         | 2018-04-24 | 6.6.346.24 | 5.6.0   | 64    | [下载 ](https://nodejs.org/download/release/v10.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V10.md#10.0.0)[文档](https://nodejs.org/dist/v10.0.0/docs/api/) |
| Node.js 9.0.0   |         | 2017-10-31 | 6.2.414.32 | 5.5.1   | 59    | [下载 ](https://nodejs.org/download/release/v9.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V9.md#9.0.0)[文档](https://nodejs.org/dist/v9.0.0/docs/api/) |
| Node.js 8.17.0  | Carbon  | 2019-12-17 | 6.2.414.78 | 6.13.4  | 57    | [下载 ](https://nodejs.org/download/release/v8.17.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V8.md#8.17.0)[文档](https://nodejs.org/dist/v8.17.0/docs/api/) |
| Node.js 8.0.0 |  | 2017-05-30 | 5.8.283.41 | 5.0.0 | 57 | [下载 ](https://nodejs.org/download/release/v8.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V8.md#8.0.0)[文档](https://nodejs.org/dist/v8.0.0/docs/api/) |
| Node.js 7.0.0 |  | 2016-10-25 | 5.4.500.36 | 3.10.8 | 51 | [下载 ](https://nodejs.org/download/release/v7.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V7.md#7.0.0)[文档](https://nodejs.org/dist/v7.0.0/docs/api/) |
| Node.js 6.17.1 | Boron | 2019-04-03 | 5.1.281.111 | 3.10.10 | 48 | [下载 ](https://nodejs.org/download/release/v6.17.1/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V6.md#6.17.1)[文档](https://nodejs.org/dist/v6.17.1/docs/api/) |
| Node.js 6.0.0 |  | 2016-04-26 | 5.0.71.35 | 3.8.6 | 48 | [下载 ](https://nodejs.org/download/release/v6.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V6.md#6.0.0)[文档](https://nodejs.org/dist/v6.0.0/docs/api/) |
| Node.js 5.0.0 |  | 2015-10-29 | 4.6.85.28 | 3.3.6 | 47 | [下载 ](https://nodejs.org/download/release/v5.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V5.md#5.0.0)[文](https://nodejs.org/dist/v5.0.0/docs/api/) |
| Node.js 4.9.1 | Argon | 2018-03-29 | 4.5.103.53 | 2.15.11 | 46 | [下载 ](https://nodejs.org/download/release/v4.9.1/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V4.md#4.9.1)[文](https://nodejs.org/dist/v4.9.1/docs/api/) |
| Node.js 4.0.0 |  | 2015-09-08 | 4.5.103.30 | 2.14.2 | 46 | [下载 ](https://nodejs.org/download/release/v4.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V4.md#4.0.0)[文档](https://nodejs.org/dist/v4.0.0/docs/api/) |
| ...          |         |            |            |         |       |                                                              |
| io.js 1.0.0     |         | 2015-01-14 | 3.31.74.1  | 2.1.18  | 42    | [下载 ](https://iojs.org/download/release/v1.0.0/)[更新日志 ](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_IOJS.md#1.0.0)[文档](https://iojs.org/dist/v1.0.0/docs/api/) |
| Node.js 0.1.14  |         | 2011-08-26 | 1.3.15.0   |         |       | [下载 ](https://nodejs.org/download/release/v0.1.14/)[更新日志 ](https://github.com/nodejs/node-v0.x-archive/blob/v0.1.14/ChangeLog)[文档](https://nodejs.org/docs/v0.1.14/api.html) |

> 1. io.js:  1.x 到 3.x 版本被叫做 “io.js”，因为它们属于 io.js 的分支。从 Node.js 4.0.0 开始，之前版本的 io.js 与 Node.js 0.12.x 合并到统一的 Node.js 发行版中。
>
> 2. 版本更新规律：大概每月一个小版本，每年一个大版本。4.x开始首位偶数版本有LTS版本。
>
> 3. N-M-V指NODE_MODULE_VERSION。 指的是 Node.js 的 ABI (application binary interface) 版本号，用来确定编译 Node.js 的 C++ 库版本，以确定是否可以直接加载而不需重新编译。在早期版本中其作为一位十六进制值来储存，而现在表示为一个整数。



### 安装

linux用nvm安装和管理Node.js

nodejs在线更新

```shell
# 查看node版本
node -v

# 安装n模块
npm install -g n

# 查看可安装版本
n lsr -all

# 安装提定版本，如12.22.1
n 12.22.1

# 检查版本
node -v
```



### 示例1：hello world

Node.js应用程序由以下三个重要部分组成：

*  导入所需模块: 使用require指令来加载JavaScript模块
*  创建一个服务器: 服务器这将听监听在Apache HTTP服务器客户端的请求。
*  读取请求并返回响应： 在前面的步骤中创建的服务器将响应读取由客户机发出的HTTP请求(可以是一个浏览器或控制台)并返回响应。

 文件 helloworld.js

```javascript
var http = require("http")
http.createServer(function (request, response) {
   response.writeHead(200, {'Content-Type': 'text/plain'});
   response.end('Hello World\n');
}).listen(8081);
console.log('Server running at http://127.0.0.1:8081/');
```



现在执行helloworld.js来启动服务器，如下：

`$ node helloworld.js`

在任何浏览器中打开地址：http://127.0.0.1:8081/，看看下面的结果。



### 示例2：sacdl-project

源码：https://github.com/imfly/sacdl-project

演示：http://imfly.github.io/sacdl-project/

SDCDL是加密货币开发语言统计分析, Statistical Analysis of Cryptocurrency Development Languages，是[《Nodejs开发加密货币》](https://github.com/imfly/bitcoin-on-nodejs) 入门部门实例程序。是一个基于gihub的Api进行二次开发的统计分析工具。



**功能**

*  自定义搜索。可以代替github针对版本库的高级搜索，自定义搜索任何关键字（不限于加密货币）;

*  数据可视化。可以输出列表、柱状图、矩阵图等交互性视图，方便、直观;

*  扩展性能好。集成了d3.js，可以根据自己喜好，添加和定制任何视图样式; ...

*  开发

 ```shell
# 安装依赖包
git clone https://github.com/imfly/sacdl-project.git
cd sacdl-project
npm install   # 自动查找package.json里依赖包并安装
bower install

# 构建代码
gulp
# 部署到 gh-pages
gulp deploy
 ```



## 技术原理篇

### 并发处理：事件和回调

Node JS是单线程应用程序，但它通过事件和回调概念，支持并发。 由于Node JS每一个API是异步的，作为一个单独的线程，它使用异步函数调用，以保持并发性。Node JS使用观察者模式。Node线程保持一个事件循环，每当任何任务得到完成，它触发这标志着该事件侦听器函数执行相应的事件。



**什么是回调?**

回调是一个异步等效的功能。在完成特定任务回调函数被调用。 Node大量使用了回调。Node的所有的API都支持回调这样的一种方式。



**事件**

Node.js运行在一个单线程模式，但它使用一个事件驱动范例来处理并发。它还有助于创建子进程，以充分利用并行处理的多核CPU系统。

子进程总是有三个流child.stdin，child.stdout和child.stderr这可能与父进程stdio流共享。

Node提供child_process模块，该模块具有以下三个主要的方法来创建子进程。

*  exec - child_process.exec方法在shell/控制台运行一个命令并缓冲输出。
*  spawn - child_process.spawn启动一个新的过程，一个给定的指令
*  fork - child_process.fork方法是指定spawn()来创建子进程的一个特例。



### 全局对象和模块

Node.js的全局对象是具有全局性的，它们可在所有的模块中应用。我们并不需要包括这些对象在应用中，而可以直接使用它们。这些对象的模块，函数，字符串和对象本身，如下所述。

表格 9 node.js全局对象列表

| 全局对象      | 简介                        | 备注 |
| ------------------- | ------------------------------------------------------------ | ---- |
| __filename    | 表示正在执行的代码的文件名，解析绝对路径。          |   |
| __dirname     | 表示当前正在执行的脚本所在目录的名称。           |   |
| setTimeout(cb, ms)  | 用于至少毫秒毫秒后运行回调cb。实际延迟取决于外部因素，如OS计时器粒度和系统负载。计时器不能跨越超过24.8天。 |   |
| clearTimeout(t)  | 用来停止以前用的setTimeout()创建一个定时器。这里t是由setTimeout()函数返回的计时器。 |   |
| setInterval(cb, ms) | 用来至少毫秒后重复运行回调cb。实际延迟取决于外部因素，如OS计时器粒度和系统负载。计时器不能跨越超过24.8天。 |   |
|         |                          |   |



表格 10 node.js内置模块列表

| 模块    | 简介                       | 备注 |
| ------- | ----------------------------------------------------------- | ---- |
| Console | 用于打印输出和错误信息                 |   |
| Process | 用于获取当前进程的信息。提供处理活动有关的多个事件    |   |
| OS   | 提供基本的操作系统相关的实用功能             |   |
| Path    | 提供工具，用于处理和转换文件的路径           |   |
| NET  | 提供服务器和客户端的数据流。充当网络包装        |   |
| DNS  | 提供做实际DNS查询的功能，以及使用底层操作系统的名称解析功能 |   |
| Domain  | 提供一个方式来处理多个不同的I/O操作，作为一个组       |   |



## 相关框架：Express

**Express**

Express是一个最小的，灵活的Node.js Web应用程序框架，它提供了一套强大的功能来开发Web和移动应用程序。 它有助于基于Node Web应用程序的快速开发。下面是一些Express框架的核心功能：

*  允许设立中间件响应HTTP请求

*  定义了用于执行基于HTTP方法和URL不同动作的路由表

*  允许动态渲染基于参数传递给模板HTML页面



## 本章参考

[1]:  https://www.runoob.com/nodejs/nodejs-tutorial.html  "Node.js 教程"



# 4  Vue.js

vue官方文档：https://cn.vuejs.org/v2/guide/

vue资源精选：http://vue.awesometiny.com/

vue GitHub地址：https://github.com/vuejs/vue

Vue2.x 框架配置：vue-cli + vue-router + vuex

## 入门篇

### 版本

表格 Vue.js版本说明 [`CHANGELOG.md`](https://github.com/facebook/react/blob/main/CHANGELOG.md)

| 版本 | 发布时间 | 说明                                                         |
| ---- | -------- | ------------------------------------------------------------ |
| 1.0  | 2014     |                                                              |
| 2.0  |          |                                                              |
| 3.0  | 2020.9   | 提供了更好的性能、更小的捆绑包体积、更好的 TypeScript 集成、用于处理大规模用例的新 API。 |



### vue-cli

安装：

```shell
# 全局安装 vue-cli
cnpm install vue-cli -g

# 创建一个基于 webpack 模板的新项目
$ vue init webpack [my-project]
```

Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：

- 通过 `@vue/cli` 搭建交互式的项目脚手架。
- 通过 `@vue/cli` + `@vue/cli-service-global` 快速开始零配置原型开发。
- 一个运行时依赖 (@vue/cli-service)，该依赖：
  - 可升级；
  - 基于 webpack 构建，并带有合理的默认配置；
  - 可以通过项目内的配置文件进行配置；
  - 可以通过插件进行扩展。
- 一个丰富的官方插件集合，集成了前端生态中最好的工具。
- 一套完全图形化的创建和管理 Vue.js 项目的用户界面。

CLI 服务是构建于 [webpack](http://webpack.js.org/)[ ](http://webpack.js.org/) 和 [webpack-dev-server](https://github.com/webpack/webpack-dev-server)之上的。它包含了：

- 加载其它 CLI 插件的核心服务；
- 一个针对绝大部分应用优化过的内部的 webpack 配置；
- 项目内部的 `vue-cli-service` 命令，提供 `serve`、`build` 和 `inspect` 命令。



### vue项目结构

**package.json** :  npm init产生。本地项目的包定义文件。

```json
{
 "author": "keefe <wuqifu@gmail.com>",
 "name": "hello",
 "description": "A example for write a module",
 "version": "0.0.1",
 "repository": {
 "url": ""
 },
 "main": "hello.js",
 "engines": {
 "node": "*"
 },
 "dependencies": {},
 "devDependencies": {}
}
```

nodejs/vue项目典型结构如下图

![vue项目结构](../../media/sf_reuse/framework/frame_nodejs_01.png)



vue项目结构说明表

| 一级目录或文件    | 二级目录或文件 | 说明                        |
| ----------------- | -------------- | ------------------------------------------------------------ |
| node_modules   |       | 项目全局模块目录 -g                  |
| src      |       |                          |
|          | assets      | 静态资源目录                      |
|          | component   | 组件目录，里面文件类似app.vue格式             |
|          | **app.vue** | 项目入口文件。定义vue的template、script、style      |
|          | main.js     | 项目的核心文件                    |
| .babelrc    |       | JS构建。                       |
| package.json   |       | 项目的包定义文件，包括依赖组件、脚本等。npm init [proj] 时初始化。 |
| package-lock.json |       | `npm install`时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号。不能update依赖组件。 |
| webpack.config.js |       | webpack打包配置文件 |
|          |       |                          |

```vue
# App.uve, 导入其它地方定义的vue组件
<script>
import firstcomponent from './component/firstcomponent.vue'
</script>
```



VUE项目的目录文件详细说明

```
├── build                      # 构建相关
├── static                     # 静态资源
│   │── img                    # 图片
│   │── favicon.ico            # favicon图标
│   └── index.html             # html模板
│   │── Tinymce                # 富文本
├── src                        # 源代码
│   ├── api                    # 所有请求
│   ├── assets                 # 主题 字体等静态资源
│   ├── components             # 全局公用组件
│   ├── directive              # 全局指令
│   ├── icons                  # 项目所有 svg icons
│   ├── lang                   # 国际化 language
│   ├── layout                 # 全局 layout
│   ├── router                 # 路由
│   ├── store                  # 全局 store管理
│   ├── styles                 # 全局样式
│   ├── utils                  # 全局公用方法
│   ├── views                  # views 所有页面
│   ├── App.vue                # 入口页面,根组件
│   ├── main.js                # 入口文件 加载组件 初始化等
│   └── permission.js          # 权限管理
├── tests                      # 测试
├── .env.xxx                   # 环境变量配置
├── .eslintrc.js               # eslint 配置项
├── .gitignore                 # git忽略项
├── .babelrc                   # babel-loader 配置
├── .travis.yml                # 自动化CI配置
├── vue.config.js              # vue-cli 配置
└── package.json               # 项目基本信息，如依赖模块
```

说明：一个.vue文件就是一个组件。



## 技术原理篇

### Vue的生命周期

![img](../../media/sf_reuse/framework/frame_vue_001.png)

图 vue生命周期示意图



### Vue数据双向绑定

MVVM架构模式。

Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

![img](../../media/sf_reuse/framework/frame_vue_002.png)



* *Observer* 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。

* **Compile** 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。

* **Watcher** 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。

* **Dep** 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。



## vue插件

### vuex



### vue-router





## 本章参考

[1]:  https://cn.vuejs.org/  " 官网文档"
[2]:  https://www.runoob.com/w3cnote/vue2-start-coding.html  "Vue2.0 新手入门 — 从环境搭建到发布"
[3]: https://www.cnblogs.com/ppap/p/11189092.html "pycharm新建Vue项目"
[4]:  https://panjiachen.github.io/vue-element-admin-site/zh/ "基于vue和element构建的后台前端解决方案"



# 5 React

官网：https://zh-hans.reactjs.org

源码官网：https://github.com/facebook/react

入门项目：   https://harman052.github.io/react-tutorial-solutions

## 入门篇

### 简介

React 是一个用于构建用户界面的 JAVASCRIPT 库。 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。

**React 特点**

- **1.声明式设计** −React采用声明范式，可以轻松描述应用。
- **2.高效** −React通过对DOM的模拟，最大限度地减少与DOM的交互。
- **3.灵活** −React可以与已知的库或框架很好地配合。
- **4.JSX** − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。
- **5.组件** − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。
- **6.单向响应的数据流** − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。



**DEMO**

```react
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello React!</title>
    <script src="//www.w3cschool.cn/statics/assets/react/react.min.js"></script>
    <script src="//www.w3cschool.cn/statics/assets/react/react-dom.min.js"></script>
    <script src="//www.w3cschool.cn/statics/assets/react/babel.min.js"></script>
  </head>
  <body>
    <div id="example"></div>
    <script type="text/babel">
      ReactDOM.render(
        <h1>Hello, world!</h1>,
        document.getElementById('example')
      );
    </script>
  </body>
</html>
```

说明：使用 JSX，则 <script> 标签的 type 属性需要设置为 text/babel。



表格 React版本说明

| 版本   | 发布时间   | 更改说明                                                     | 备注                                  |
| ------ | ---------- | ------------------------------------------------------------ | ------------------------------------- |
| 0.3.0  | 2013-5-29  | Initial public release                                       | 第一个公共版本                        |
| ...    |            |                                                              |                                       |
| 0.14.8 | 2016-5-29  |                                                              | 大版本之前的最后一个0.x版本。         |
| 15.0   | 2016-8-7   | 架构级改动                                                   | 开始启用大版本号                      |
| 16.0   | 2017-9-26  | 16.8(2019-2-6)增加HOOK。                                     | 16.x最后一个版本是16.14(2020-10-14)。 |
| 17.0   | 2020-10-20 | 1.Add `react/jsx-runtime` and `react/jsx-dev-runtime`<br>2.Build component stacks from native error frames.<br>... |                                       |

> 版本更新详见 [React - Versions (reactjs.org)](https://zh-hans.reactjs.org/versions/)   [CHANGELOG.md](https://github.com/facebook/react/blob/main/CHANGELOG.md)



### 入门步骤

```shell
# step1: 安装全局包 babel/webpack/
$ npm install babel -g
$ npm install webpack -g
$ npm install webpack-dev-server -g

# step2: 初始化，创建react项目 reactapp
mkdir reactapp
cd reactapp
npm init  # 生成package.json

# step3: 安装依赖包 和babel插件
# react依赖包 react react-dom
$ npm install react react-dom --save
$ npm install react-dom --save

# react-redux依赖包
$ npm install redux redux-actions  react-redux

# react-router依赖包
$ npm install react-router react-router-redux

# redux调试工具包
$ npm install redux-devtools

# babel：
$ npm install babel-core babel-loader babel-preset-react babel-preset-es2015
```



**step4: 创建文件** webpack.config.js, index.html, app.jsx, main.jsx

webpack.config.js

```js
var config = {
   entry: './main.js',

   output: {
      path:'./',
      filename: 'index.js',
   },

   devServer: {
      inline: true,
      port: 7777
   },

   module: {
      loaders: [ {
         test: /\.jsx?$/,
         exclude: /node_modules/,
         loader: 'babel',

         query: {
            presets: ['es2015', 'react']
         }
      }]
   }
}

module.exports = config;
```

- **entry:** 指定打包的入口文件 **main.js**。
- **output：**配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。
- **devServer：**设置服务器端口号为 **7777**，端口后你可以自己设定 。
- **module：**定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。



**index.html**

设置 **div id = "app"** 为我们应用的根元素，并引入 **index.js** 脚本文件。

```html
<!DOCTYPE html>
<html>

   <head>
      <meta charset = "UTF-8">
      <title>React App - W3Cschool教程(w3cschool.cn)</title>
   </head>

   <body>
      <div id = "app"></div>
      <script src = "index.js"></script>
   </body>

</html>
```



index.js 文件代码 （导入组件App)

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

import App from './App.jsx';

ReactDOM.render(<App />, document.getElementById('app'))
```



App.jsx  (定义组件)

```jsx
import React from 'react';

class App extends React.Component {
   render() {
      return (
         <div>
            Hello World!!!<br />
            欢迎来到W3Cschool教程学习！！！
         </div>
      );
   }
}

export default App;
```



**step5**  启动服务 :  `npm start`

访问服务  http://localhost:7777/



### JSX语法

React发明了JSX，利用HTML语法来创建虚拟DOM。React的核心机制之一就是可以在内存中创建虚拟的DOM元素。以此来减少对实际DOM的操作从而提升性能。

JSX 即Javascript XML，它是对JavaScript 语法扩展。React 使用 JSX 来替代常规的 JavaScript。当遇到<，JSX就当HTML解析，遇到{就当JavaScript解析。

**JSX的优点：**

- 快，执行速度更快，因为它在编译为JavaScript代码后进行了优化。
- 可以使用熟悉的语法仿照HTML来定义虚拟DOM。从而编写模板更加简单快速。

使用JSX：如果要使用JSX，需要得到语法的支持，你可以使用Babel来进行转换。

每个 JSX 元素只是调用 `React.createElement(component, props, ...children)` 的语法糖。

因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。



## 原理篇

引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js：

- **react.min.js** - React 的核心库
- **react-dom.min.js** - 提供与 DOM 相关的功能
- **babel.min.js** - Babel 可以将 ES6 代码转为 ES5  代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和  babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平。

```tsx
ReactDOM.render(
	<h1>Hello, world!</h1>,
	document.getElementById('example')
);
```

以上代码将一个 h1 标题，插入 id="example" 节点中。



### React组件生命周期

React 组件是可复用的小的代码片段，它们返回要在页面中渲染的 React 元素。JS函数和React.Component派生类都是组件。

React 组件从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。

React规范里以小写字母开头的组件视为原生 DOM 标签，如<div />代表 HTML 的 div 标签；大写字母开头的为React组件，如<App />。

* function函数组件：

  ```tsx
  const Example = (props) => {
    // 你可以在这使用 Hook
    return <div />;
  }
  // 或者 function
  function Example(props) {
    return <div />;
  }
  ```

* class类组件：类组件可分为简单组件和有状态组件。简单组件只需继承React.Component，并不涉及数据变化。有状态组件则有数据交互。示例如下，

```tsx
// 除了使用外部数据（通过 this.props 访问）以外，组件还可以维护其内部的状态数据（通过 this.state 访问）。
// 当组件的状态数据改变时，组件会再次调用 render() 方法重新渲染对应的标记。
class Timer extends React.Component {
  constructor(props) {  //组件挂载时第一个执行方法
    super(props);		// props外部数据
    this.state = { seconds: 0 };	// 需要保存的组件内部数据
  }

  tick() {
    this.setState(state => ({   //this.setState()保存组件内部数据： 此处秒数+1
      seconds: state.seconds + 1
    }));
  }

  componentDidMount() {	//组件挂载时 最后一个方法: 设置定时器，每隔1秒计数加1
    this.interval = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {	//组件卸载：清除定时器
    clearInterval(this.interval);
  }

  render() {	//组件渲染方法，执行后可以读取DOM. this.state用来访问组件内部数据
    return (
      <div>
        Seconds: {this.state.seconds}
      </div>
    );
  }
}

ReactDOM.render(  //DOM树渲染，在指定位置插入组件，如下在div id=timer-example位置插入Timer组件
  <Timer />,
  document.getElementById('timer-example')
);
```



React 组件基本由三个部分组成，

1. 属性 props： React 组件的输入。它们是从父组件向下传递给子组件的数据。不可被修改。
2. 状态 state：当组件中的一些数据在某些时刻发生变化时，这时就需要使用 `state` 来跟踪状态。
3. 生命周期方法：用于在组件不同阶段执行自定义功能。组件的生命周期状态包括挂载、更新和卸载，另外错误处理。
   * 挂载时调用顺序： constructor() static getDerivedStateFromProps() render() componentDidMount()
   * 更新时调用顺序：static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate()
   * 卸载：componentWillUnmount()
   * 错误处理：static getDerivedStateFromError() componentDidCatch()



![image-20210716005722203](../../media/sf_reuse/framework\frame_react_001.png)

图 React组件生命周期 （[React组件生命周期图谱](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)）

React 组件的生命周期可分成三个状态：

- Mounting：已插入真实 DOM
- Updating：正在被重新渲染
- Unmounting：已移出真实 DOM



生命周期的方法有：

- **componentWillMount** 在渲染前调用,在客户端也在服务端。
- **componentDidMount** : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。
- **componentWillReceiveProps** 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。
- **shouldComponentUpdate** 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。
  可以在你确认不需要更新组件时使用。
- **componentWillUpdate**  在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。
- **componentDidUpdate** 在组件完成更新后立即调用。在初始化时不会被调用。
- **componentWillUnmount**在组件从 DOM 中移除的时候立刻被调用。

这些方法的详细说明，可以参考[官方文档](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods)。

React 组件 API。我们将讲解以下7个方法:

- 设置状态：setState
- 替换状态：replaceState
- 设置属性：setProps
- 替换属性：replaceProps
- 强制更新：forceUpdate
- 获取DOM节点：findDOMNode
- 判断组件挂载状态：isMounted



### ReactDOM.render渲染原理

1. 首先我们写的JSX语法，都被Babel进行转义，然后使用React.creatElement进行创建，转换为React的元素
2. 使用ReactDom.render创建root对象，执行root.render。
3. 一系列函数调用之后，workLoop在一次渲染周期内，遍历虚拟DOM，将这些虚拟DOM传递给performUnitOfWork函数，performUnitOfWork函数开启一次workTime，将虚拟DOM传递给beginWork。
4. beginWork根据虚拟DOM的类型，进行不同的处理，将子元素处理为Fiber类型，为Fiber类型的虚拟DOM添加父节点、兄弟节点等（就是转换为Fiber树）。
5. beginWork处理完一次操作之后，返回需要处理的子元素再继续处理，直到沒有子元素（即返回null），
6. 此时performUnitOfWork调用completeUnitOfWork进行初始化生命周期的挂载，以及调用completeWork进行DOM的渲染。
7. completeWork对节点类型进行操作，发现是html相关的节点类型，添加渲染为真实的DOM。
8. 最后将所有的虚拟DOM，渲染为真实的DOM。



### HOOK 钩子

*Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。

Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：

- 只能在**函数最外层**调用 Hook。不要在循环、条件判断或者子函数中调用。
- 只能在 **React 的函数组件**中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）



## 实践篇

tic-tac-toe(三连棋)游戏代码: **[最终成果](https://codepen.io/gaearon/pen/gWWZgR?editors=0010)**.

### React插件

以下工具链为 React 提供更多更具灵活性的方案。推荐给更有经验的使用者：

- **[Neutrino](https://neutrinojs.org/)** 把 [webpack](https://webpack.js.org/) 的强大功能和简单预设结合在一起。并且包括了 [React 应用](https://neutrinojs.org/packages/react/)和 [React 组件](https://neutrinojs.org/packages/react-components/)的预设。
- **[Nx](https://nx.dev/react)** 是针对全栈 monorepo 的开发工具包，其内置了 React，Next.js，[Express](https://expressjs.com/) 等。
- **[Parcel](https://parceljs.org/)** 是一个快速的、零配置的网页应用打包器，并且可以[搭配 React 一起工作](https://parceljs.org/recipes.html#react)。
- **[Razzle](https://github.com/jaredpalmer/razzle)** 是一个无需配置的服务端渲染框架，但它提供了比 Next.js 更多的灵活性。



表格 React项目常用插件

| 类别        | 插件名称                    | 插件简介                                                     |
| ----------- | --------------------------- | ------------------------------------------------------------ |
| 状态管理    | **Redux**                   | `JavaScript` 状态容器，提供可预测化的状态管理                |
|             | **Redux Saga**              | `Redux`中间件,用于管理应用程序 `Side Effect`(副作用，例如异步获取数据，访问浏览器缓存等) |
|             | **Redux Thunk**             | `Redux`的异步处理中间件                                      |
| UI组件库    | **Ant design**              | 基于 `Ant Design` 设计体系的 `React UI` 组件库，主要用于研发企业级中后台产品 |
|             | **Ant design mobile**       | 基于 `Ant Design` 设计体系的 `React UI` 移动端组件库         |
|             | **MaterialUI**              | 世界最受欢迎的基于质感设计的`React UI`库                     |
|             | **Zent**                    | 有赞 PC 端 `WebUI` 规范的 `React` 实现，提供了一整套基础的 UI 组件以及一些常用的业务组件 |
| 工具类      | **react-copy-to-clipboard** | 基于`React`的复制到剪切板组件                                |
|             | **qrcode.react**            | 基于**React**的生成二维码的组件                              |
|             | **emoji-mart**              | 基于`React`的表情库                                          |
|             |                             |                                                              |
| 数据可视化  | **AntV**                    | 包含 `G2`、`G6`、`F2`、`L7` 以及一套完整的图表使用和设计规范, 提供强大的数据可视化需求 |
|             | **G2Plot**                  | 基于`G2`封装的开箱即用的可视化组件库                         |
| 动画/动效果 | **Halogen**                 | 使用`React`的加载动画集合                                    |
| 拖拽/排序   | **react-beautiful-dnd**     | 漂亮,可移植性 列表拖拽库                                     |
| 图像处理    | **react-image-crop**        | 强大的图片裁切库                                             |
| 编辑器相关  | **braft-editor**            | 富文本编辑器                                                 |
| 地图相关    |                             | **google-map-react** 谷歌地图插件 <br>**react-amap** 高德地图插件 <br>**@uiw/react-baidu-map** 百度地图 |
| 脚手架      | **Create React App**        | 初学者必备`React`傻瓜式脚手架                                |
|             | **Next.js**                 | 构建服务端渲染的`React`脚手架                                |
|             | **umi**                     | 企业级前端应用框架                                           |
|             | **webpack3_react**          | 兼容`IE9+`且提供完整的`React`全家桶解决方案                  |



#### react-redux

2014年 Facebook 提出了 [Flux](https://www.ruanyifeng.com/blog/2016/01/flux.html) 架构的概念，引发了很多的实现。2015年，[Redux](https://github.com/reactjs/redux) 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。

Flux将一个应用分成四个部分。

> - **View**： 视图层
> - **Action**（动作）：视图层发出的消息（比如mouseClick）
> - **Dispatcher**（派发器）：用来接收Actions、执行回调函数
> - **Store**（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

![img](https://www.ruanyifeng.com/blogimg/asset/2016/bg2016011503.png)

Flux 的最大特点，就是数据的"单向流动"。任何相邻的部分都不会发生数据的"双向流动"。这保证了流程的清晰。这就是React的单向数据绑定，区别于Vue的双向绑定。数据单向流动流程详细说明如下：

```shell
1. 用户访问 View
2. View 发出用户的 Action
3. Dispatcher 收到 Action，要求 Store 进行相应的更新
4. Store 更新后，发出一个"change"事件
5. View 收到"change"事件后，更新页面
```

Redux思想：WEB应用是一个状态机，视图(View) 与状态(State) 一一对应。所有的状态保存在一个对象（Store）里。reducer是生成新状态。

![img](https://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg)

Redux数据流向过程：
1）用户发出Action（进行点击click、输入input等事件，子组件通过callback调用最外层组件的自定义事件。

2）callback中执行Dispatcher（actions creators(data)）。 或者 `store.dispatch(action);`

3）Store监听到action被触发，执行相应的Reducer，State被改变。监听函数listener `store.subscribe(listener);`

4）页面render

React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。

React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。

实现方式：

* connect： 用于从 UI 组件生成容器组件。`function connect(mapStateToProps, mapDispatchToProps, mergeProps)`
* Provider组件：让容器组件拿到`state`。



#### react-router

`Router`组件本身只是一个容器，真正的路由要通过`Route`组件定义。

```
import { Router, Route, hashHistory } from 'react-router';

render((
  <Router history={hashHistory}>
    <Route path="/" component={App}/>
  </Router>
), document.getElementById('app'));
```



#### **react-router-dom**

React Router附带了一些HOOK，可让您访问路由器的状态并从组件内部执行导航。

```tsx
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router, Route } from "react-router-dom";

ReactDOM.render(
  <Router>
    <div>
      <Route exact path="/">
        <Home />
      </Route>
      <Route path="/news">
        <NewsFeed />
      </Route>
    </div>
  </Router>,
  node
);
```



#### react-script

react-script 配置和脚本启动react项目。

```shell
$ npm show react-script

react-script@2.0.5 | MIT | deps: none | versions: 15
http://github.com/1j01/react-script/

dist
.tarball: https://registry.nlark.com/react-script/download/react-script-2.0.5.tgz
.shasum: 9dac20f97cff1fb40f5b4084e3f44b82e3001572

maintainers:
- 1j01 <isaiahodhner@gmail.com>

dist-tags:
latest: 2.0.5

published over a year ago by 1j01 <isaiahodhner@gmail.com>
```



模块结构

```shell
$ tree -L 2
.
├── bin
│   └── react-scripts.js
├── config
│   ├── env.js
│   ├── getHttpsConfig.js
│   ├── jest
│   ├── modules.js
│   ├── paths.js
│   ├── pnpTs.js
│   ├── webpack.config.js
│   └── webpackDevServer.config.js
├── lib
│   └── react-app.d.ts
├── LICENSE
├── node_modules
│   ├── fs-extra
│   └── graceful-fs
├── package.json
├── README.md
├── scripts
│   ├── build.js
│   ├── eject.js
│   ├── init.js
│   ├── start.js
│   ├── test.js
│   └── utils
├── template
│   └── README.md
└── template-typescript
    └── README.md
```



`react-scripts.js`文件会根据参数去判断执行哪种构建脚本，比如当前参数是`start`，那么就会执行`scripts/start.js`构建脚本

支持命令有：

* build  构建生产环境的包
* eject  释放配置文件
* init
* start  启动开发web服务器，依赖于webpack-dev-server
* test



脚本命令示例: /react-scripts/scripts/start.js

```js
const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');

// Tools like Cloud9 rely on this.
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || '0.0.0.0';

...

// 浏览器打开web服务
checkBrowsers(paths.appPath, isInteractive)
  .then(() => {
    // We attempt to use the default port but if it is busy, we offer the user to
    // run on a different port. `choosePort()` Promise resolves to the next free port.
    return choosePort(HOST, DEFAULT_PORT);
  })
  .then(port => {
    if (port == null) {
      // We have not found a port.
      return;
    }
    ...

	// 启动webpack-dev-server, 传参compiler和配置数据
	const devServer = new WebpackDevServer(compiler, serverConfig);
    devServer.listen(port, HOST, err => {
      if (err) {
        return console.log(err);
      }
      if (isInteractive) {
        clearConsole();
      }

      if (env.raw.FAST_REFRESH && semver.lt(react.version, '16.10.0')) {
        console.log(
          chalk.yellow(
            `Fast Refresh requires React 16.10 or higher. You are using React ${react.version}.`
          )
        );
      }

      console.log(chalk.cyan('Starting the development server...\n'));
      openBrowser(urls.localUrlForBrowser);	//打开浏览器
    });
  .catch(err => {
    if (err && err.message) {
      console.log(err.message);
    }
    process.exit(1);
  });
```





## 本章参考

* react官网中文文档  https://zh-hans.reactjs.org
* 做了N+1个企业项目之后, 我总结了这些React必备插件 https://zhuanlan.zhihu.com/p/348669260
* [译]揭秘 React 服务端渲染 https://juejin.cn/post/6844903604453654536
* Flux 架构入门教程 https://www.ruanyifeng.com/blog/2016/01/flux.html
* React 入门实例教程(删) https://www.ruanyifeng.com/blog/2015/03/react.html
* [Redux - A predictable state container for JavaScript apps. | Redux](https://redux.js.org/)   https://redux.js.org/
* 这可能是最通俗易懂的React 渲染原理及性能优化 https://blog.csdn.net/weixin_46837985/article/details/106642294?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-4&spm=1001.2101.3001.4242
* ReactDom render原理剖析 https://blog.csdn.net/weixin_33912453/article/details/88028171
* 深入理解ReactDOM.render 是如何串联渲染链路的全过程 https://blog.csdn.net/xgangzai/article/details/117794098?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-9.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-9.control
* React系列---Webpack环境搭建（一）手动搭建 https://segmentfault.com/a/1190000009902941
* React系列---Webpack环境搭建（二）不同环境不同配置 https://segmentfault.com/a/1190000009952845
* react-scripts实现原理 https://segmentfault.com/a/1190000021881152



#  参考资料

**参考链接**

*  知乎专题-趣谈前端 https://zhuanlan.zhihu.com/p/348669260



# 附录

